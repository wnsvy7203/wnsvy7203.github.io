---
title: "[프로그래머스] Lv.2 아날로그 시계 (C++)"
date: 2024-02-15 00:05:00 +09:00
categories: [Algorithm, 프로그래머스]
tags: [Algorithm, 프로그래머스, C++, Lv.2]
---
## **문제**
[[PCCP 기출문제] 3번 / 아날로그 시계](https://school.programmers.co.kr/learn/courses/30/lessons/250135)

시침, 분침, 초침이 있는 아날로그시계가 있습니다. 시계의 시침은 12시간마다, 분침은 60분마다, 초침은 60초마다 시계를 한 바퀴 돕니다. 따라서 시침, 분침, 초침이 움직이는 속도는 일정하며 각각 다릅니다. 이 시계에는 초침이 시침/분침과 겹칠 때마다 알람이 울리는 기능이 있습니다. 당신은 특정 시간 동안 알람이 울린 횟수를 알고 싶습니다.

다음은 0시 5분 30초부터 0시 7분 0초까지 알람이 울린 횟수를 세는 예시입니다.

![Imgur](https://i.imgur.com/yKs5Zw0.png)
- 가장 짧은 바늘이 시침, 중간 길이인 바늘이 분침, 가장 긴 바늘이 초침입니다.
- 알람이 울리는 횟수를 세기 시작한 시각은 0시 5분 30초입니다.
- 이후 0시 6분 0초까지 초침과 시침/분침이 겹치는 일은 없습니다.

![Imgur](https://i.imgur.com/stzWwkq.png)
- 약 0시 6분 0.501초에 초침과 시침이 겹칩니다. 이때 알람이 한 번 울립니다.
- 이후 0시 6분 6초까지 초침과 시침/분침이 겹치는 일은 없습니다.

![Imgur](https://i.imgur.com/WEKRCKn.png)
- 약 0시 6분 6.102초에 초침과 분침이 겹칩니다. 이때 알람이 한 번 울립니다.
- 이후 0시 7분 0초까지 초침과 시침/분침이 겹치는 일은 없습니다.

0시 5분 30초부터 0시 7분 0초까지는 알람이 두 번 울립니다. 이후 약 0시 7분 0.584초에 초침과 시침이 겹쳐서 울리는 세 번째 알람은 횟수에 포함되지 않습니다.

다음은 12시 0분 0초부터 12시 0분 30초까지 알람이 울린 횟수를 세는 예시입니다.

![Imgur](https://i.imgur.com/Z8CrRfp.png)
- 알람이 울리는 횟수를 세기 시작한 시각은 12시 0분 0초입니다.
- 초침과 시침, 분침이 겹칩니다. 이때 알람이 한 번 울립니다. 이와 같이 0시 정각, 12시 정각에 초침과 시침, 분침이 모두 겹칠 때는 알람이 한 번만 울립니다.

![Imgur](https://i.imgur.com/YcRcb9w.png)
이후 12시 0분 30초까지 초침과 시침/분침이 겹치는 일은 없습니다.

12시 0분 0초부터 12시 0분 30초까지는 알람이 한 번 울립니다.

알람이 울리는 횟수를 센 시간을 나타내는 정수 `h1`, `m1`, `s1`, `h2`, `m2`, `s2`가 매개변수로 주어집니다. 이때, 알람이 울리는 횟수를 return 하도록 solution 함수를 완성해주세요.
<br>

## **제한사항**
- 0 ≤ `h1`, `h2` ≤ 23
- 0 ≤ `m1`, `m2` ≤ 59
- 0 ≤ `s1`, `s2` ≤ 59
- `h1시 m1분 s1초`부터 `h2시 m2분 s2초`까지 알람이 울리는 횟수를 센다는 의미입니다.
    - `h1시 m1분 s1초` < `h2시 m2분 s2초`
    - 시간이 23시 59분 59초를 초과해서 0시 0분 0초로 돌아가는 경우는 주어지지 않습니다.
<br>

## **체감 난이도**
🟩🟩🟩⬜⬜
<br>

## **풀이**
직접 문제를 풀 때는 어떻게 풀어야 하는 것인지 고민을 많이 했지만, 막상 풀이를 작성하다 보니 풀이 자체는 간단한 것 같다.

아날로그의 시계는 매 초, 초침은 6도 / 분침은 0.1도 / 시침은 1/120도 움직이게 된다. 문제에서 요구하는 것은 초침이 분침/시침 중 하나와 겹칠 때마다 알람이 울린다고 했으니, **각 침의 각도가 일치하는 횟수**를 구하면 되는 것이다.

다만, 주의해야 할 점은 **초 단위로만 각도가 일치하는 횟수를 구하면 놓치게 되는 경우가 발생한다**는 것이다. 위의 문제 예시에서도 확인할 수 있듯이, 0시 6분 0.501초에 초침과 시침이 겹친다거나, 0시 6분 6.102초에 초침과 분침이 겹친다거나 하기 때문에 다른 방법이 필요하다.

따라서 여기서는, 현재 시간 `now`와 1초 뒤 시간의 초침, 분침, 시침의 각도를 각각 계산한 후, 두 각도를 비교하기로 했다.

`now`에서는 초침 각도가 분침 각도보다 작았다. 그런데, 만약 1초 후 초침 각도가 분침 각도보다 커졌다면 당연히 초침과 분침은 1초 안에 반드시 한 번 겹쳐야 한다. 시침 역시 마찬가지이다.

또 하나 주의해야 할 점은, 1초 안에 초침이 분침과도 만나고 시침과도 만났을 때, **초침/시침/분침이 일치하는 경우가 있을 수 있는데 문제에서 이런 경우에는 알람이 한 번만 울린다**고 했으니, 만약 **1초 뒤에 시침과 분침이 겹친다면 1을 빼는 방식으로 중복 계산을 피했다**.
<br>

## **정답 코드**
```c++
#include <string>
#include <vector>

using namespace std;

int answer;

// 주어진 초단위 시간을 시침, 분침, 초침의 각도 순으로 반환하는 함수
vector<double> degree(int s)
{
    int h = s / 3600;
    s -= h * 3600;
    
    int m = s / 60;
    s -= m * 60;
    
    double d_hour = (h % 12) * 30 + m * 0.5 + s / 120.0;
    double d_minute = m * 6 + s * 0.1;
    double d_second = s * 6;
    
    return {d_hour, d_minute, d_second};
}

int solution(int h1, int m1, int s1, int h2, int m2, int s2)
{
    int start = h1*3600 + m1*60 + s1;
    int end = h2*3600 + m2*60 + s2;
    
    vector<double> v1 = degree(start);
    if (v1[0] == v1[1] || v1[1] == v1[2] || v1[2] == v1[0])
        answer++;
    
    for (int now = start; now < end; now++)
    {
        vector<double> cur = degree(now);
        vector<double> next = degree(now+1);
        
        // 1. 시침과 초침이 겹친 경우
        if (cur[0] > cur[2] && next[0] <= next[2])
            answer++;
        else if (cur[0] > 354 && cur[2] == 354)
            answer++;    
        
        // 2. 분침과 초침이 겹친 경우
        if (cur[1] > cur[2] && next[1] <= next[2])
            answer++;
        else if (cur[1] > 354 && cur[2] == 354)
            answer++;
        
        // 3. 초침과 분침/시침이 겹쳤는데, 분침과 시침도 겹친 경우
        if (next[0] == next[1])
            answer--;
    }
    
    return answer;
}
```