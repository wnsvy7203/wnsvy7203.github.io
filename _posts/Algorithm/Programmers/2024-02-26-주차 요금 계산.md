---
title: "[프로그래머스] Lv.2 주차 요금 계산 (C++)"
date: 2024-02-26 12:28:00 +09:00
categories: [Algorithm, 프로그래머스]
tags: [Algorithm, 프로그래머스, C++, Lv.2]
---
## **문제**
[[2022 KAKAO BLIND RECRUITMENT] 주차 요금 계산](https://school.programmers.co.kr/learn/courses/30/lessons/92341)

주차장의 요금표와 차량이 들어오고(입차) 나간(출차) 기록이 주어졌을 때, 차량별로 주차 요금을 계산하려고 합니다. 아래는 하나의 예시를 나타냅니다.

- **요금표**

|기본 시간(분)|기본 요금(원)|단위 시간(분)|단위 요금(원)|
|---|---|---|---|
|180|5000|10|600|

- **입/출차 기록**

|시각(시:분)|차량 번호|내역|
|---|---|---|
|05:34|5961|입차|
|06:00|0000|입차|
|06:34|0000|출차|
|07:59|5961|출차|
|07:59|0148|입차|
|18:59|0000|입차|
|19:09|0148|출차|
|22:59|5961|입차|
|23:00|5961|출차|

- **자동차별 주차 요금**

|차량 번호|누적 주차 시간(분)|주차 요금(원)|
|---|---|---|
|0000|34 + 300 = 334|5000 + ⌈ (334 - 180) / 10 ⌉ x 600 = 14600|
|0148|670|5000 + ⌈ (670 - 180) / 10 ⌉ x 600 = 34400|
|5961|145 + 1 = 146|5000|

- 어떤 차량이 입차된 후에 출차된 내역이 없다면, 23:59에 출차된 것으로 간주합니다.
    - `0000`번 차량은 18:59에 입차된 이후, 출차된 내역이 없습니다. 따라서, 23:59에 출차된 것으로 간주합니다.
- 00:00부터 23:59까지의 입/출차 내역을 바탕으로 차량별 누적 주차 시간을 계산하여 요금을 일괄로 정산합니다.
- 누적 주차 시간이 `기본 시간` 이하라면, `기본 요금`을 청구합니다.
- 누적 주차 시간이 `기본 시간`을 초과하면, `기본 요금`에 더해서, 초과한 시간에 대해서 `단위 시간` 마다 `단위 요금`을 청구합니다.
    - 초과한 시간이 단위 시간으로 나누어 떨어지지 않으면, 올림합니다.
    - `⌈`a`⌉` : a보다 작지 않은 최소의 정수를 의미합니다. 즉, 올림을 의미합니다.

주차 요금을 나타내는 정수 배열 `fees`, 자동차의 입/출차 내역을 나타내는 문자열 배열 `records`가 매개변수로 주어집니다. 차량 번호가 작은 자동차부터 청구할 주차 요금을 차례대로 정수 배열에 담아서 return 하도록 solution 함수를 완성해주세요.
<br>

## **제한사항**
- fees의 길이 = 4
    - fees[0] = `기본 시간(분)`
    - 1 ≤ fees[0] ≤ 1,439
    - fees[1] = `기본 요금(원)`
    - 0 ≤ fees[1] ≤ 100,000
    - fees[2] = `단위 시간(분)`
    - 1 ≤ fees[2] ≤ 1,439
    - fees[3] = `단위 요금(원)`
    - 1 ≤ fees[3] ≤ 10,000
- 1 ≤ `records`의 길이 ≤ 1,000
    - `records`의 각 원소는 `"시각 차량번호 내역"` 형식의 문자열입니다.
    - `시각`, `차량번호`, `내역`은 하나의 공백으로 구분되어 있습니다.
    - `시각`은 차량이 입차되거나 출차된 시각을 나타내며, `HH:MM` 형식의 길이 5인 문자열입니다.
        - `HH:MM`은 00:00부터 23:59까지 주어집니다.
        - 잘못된 시각("25:22", "09:65" 등)은 입력으로 주어지지 않습니다.
    - 차량번호는 자동차를 구분하기 위한, '0'~'9'로 구성된 길이 4인 문자열입니다.
    - `내역`은 길이 2 또는 3인 문자열로, `IN` 또는 `OUT`입니다. `IN`은 입차를, `OUT`은 출차를 의미합니다.
    - `records`의 원소들은 시각을 기준으로 오름차순으로 정렬되어 주어집니다.
    - `records`는 하루 동안의 입/출차된 기록만 담고 있으며, 입차된 차량이 다음날 출차되는 경우는 입력으로 주어지지 않습니다.
    - 같은 시각에, 같은 차량번호의 내역이 2번 이상 나타내지 않습니다.
    - 마지막 시각(23:59)에 입차되는 경우는 입력으로 주어지지 않습니다.
    - 아래의 예를 포함하여, 잘못된 입력은 주어지지 않습니다.
        - 주차장에 없는 차량이 출차되는 경우
        - 주차장에 이미 있는 차량(차량번호가 같은 차량)이 다시 입차되는 경우
<br>

## **체감 난이도**
🟩🟩⬜⬜⬜
<br>

## **풀이**
차량 번호가 작은 차부터 순서대로 `answer`에 집어넣어야 하는 문제이기 때문에 차량 번호를 key 값으로 가지는 `map`을 이용했고 풀었고, `records`의 길이가 최대 1000인 것을 감안해서 완전 탐색을 사용했다.

크게 2단계로 구분해서 풀었는데,

1. 먼저 입차시간과 출차시간을 구분해서 총 주차시간을 계산한다. **이때, 입차만 하고 출차는 하지 않은 차가 있다면 23시 59분에 출차한 것으로 계산해야 한다**는 것을 감안해서 계산한다.
2. 계산된 주차시간을 `costs`에 담고, `costs`에 담긴 (key : value) 쌍을 순회하면서 주차요금을 계산하고, 계산된 주차요금을 `answer` 배열에 담는다.

아직 `map`에 대한 이해가 완벽하지 않아서 문제가 발생했는데, 왜인지는 모르겠지만 `map`을 조회하고 값을 변경한 이후에, 다시 같은 `map`을 조회하면 변경된 값을 조회하는 것이 아니라 변경하기 이전의 `map`을 조회한다.

좀 더 공부가 필요한 부분이고, 결국 다른 `map` 하나를 더 선언해서 문제를 풀 수 있었다.
<br>

## **정답 코드**
```c++
#include <string>
#include <vector>
#include <tuple>
#include <map>

using namespace std;

vector<int> solution(vector<int> fees, vector<string> records) {
    vector<int> answer;
    
    // 순서대로 {key(차량 번호): value(현재 주차 여부, 입차 시간, 주차 시간)}
    map<string, tuple<bool, int, int>> input;
    for (string record : records)
    {
        // 입/출차 구분 -> IN: 입차, OUT: 출차
        string code = record.substr(11);
        // 입/출차 시간
        int time = stoi(record.substr(0, 2)) * 60 + stoi(record.substr(3, 2));
        // 차량 번호
        string car = record.substr(6, 4);
        
        if (code == "IN")
        {
            // 입차 표시
            get<0>(input[car]) = true;
            // 입차 시간
            get<1>(input[car]) = time;
        }
        else
        {
            // 주차 시간 계산
            int parking = time - get<1>(input[car]);
            // 출차 표시
            get<0>(input[car]) = false;
            // 나중에 다시 주차할 수도 있으므로 0으로 처리
            get<1>(input[car]) = 0;
            // 주차 시간만큼 더해준다.
            get<2>(input[car]) += parking;
        }
    }
    
    // input을 순회하면서 아직 IN 상태인 차를 23:59에 출차 처리해준 후, costs 로 옮겨준다.
    map<string, int> costs;
    for (auto it : input)
    {
        if (get<0>(it.second) == true)
        {
            int parking = 1439 - get<1>(it.second);
            // 출차 처리
            get<0>(it.second) = false;

            get<1>(it.second) = 0;
            get<2>(it.second) += parking;
        }
        
        costs[it.first] = get<2>(it.second);
    }

    // 이제 costs에는 {Key(차량 번호): Value(주차 시간)} 순으로 값이 담겨 있으므로, 주차 요금을 계산해주면 된다.
    for (auto it : costs)
    {
        int parking = it.second;
        int cost = 0;
        
        // 기본 시간 이하로 주차한 경우에는 기본 요금만 부과된다.
        if (parking <= fees[0])
            cost = fees[1];
        // 기본 시간 이상으로 주차한 경우에는 기본 요금 + 단위 요금 * ⌈ (총 주차 시간 - 기본 시간) / 단위 시간 ⌉ 만큼의 요금이 부과된다.
        else
        {
            parking -= fees[0];
            cost += fees[1];

            // 기본 시간을 빼고 남은 주차 시간이 단위 시간으로 나눠떨어지면
            if (!(parking % fees[2]))
                parking /= fees[2];
            // 나눠 떨어지지 않으면 올림
            else
            {
                parking /= fees[2];
                parking++;
            }
            
            // 단위 시간 * 단위 요금
            cost += (parking * fees[3]);
        }
        
        // map에 이미 차량 번호를 기준으로 오름차순 정렬되어 있으므로, 그냥 answer 배열에 담기만 하면 된다.
        answer.push_back(cost);
    }
    
    return answer;
}
```