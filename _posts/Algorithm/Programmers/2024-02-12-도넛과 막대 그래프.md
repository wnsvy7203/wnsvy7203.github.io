---
title: "[프로그래머스] Lv.2 도넛과 막대 그래프 (C++)"
date: 2024-02-12 15:26:00 +09:00
categories: [Algorithm, 프로그래머스]
tags: [Algorithm, 프로그래머스, C++, Lv.2]
---
## **문제**
[[2024 KAKAO WINTER INTERNSHIP] 도넛과 막대 그래프](https://school.programmers.co.kr/learn/courses/30/lessons/258711)

도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프들이 있습니다. 이 그래프들은 1개 이상의 정점과, 정점들을 연결하는 단방향 간선으로 이루어져 있습니다.

- 크기가 n인 도넛 모양 그래프는 n개의 정점과 n개의 간선이 있습니다. 도넛 모양 그래프의 아무 한 정점에서 출발해 이용한 적 없는 간선을 계속 따라가면 나머지 n-1개의 정점들을 한 번씩 방문한 뒤 원래 출발했던 정점으로 돌아오게 됩니다. 도넛 모양 그래프의 형태는 다음과 같습니다.

![Imgur](https://i.imgur.com/QupT3IV.png)

- 크기가 n인 막대 모양 그래프는 n개의 정점과 n-1개의 간선이 있습니다. 막대 모양 그래프는 임의의 한 정점에서 출발해 간선을 계속 따라가면 나머지 n-1개의 정점을 한 번씩 방문하게 되는 정점이 단 하나 존재합니다. 막대 모양 그래프의 형태는 다음과 같습니다.

![Imgur](https://i.imgur.com/WNzG6G7.png)

- 크기가 n인 8자 모양 그래프는 2n+1개의 정점과 2n+2개의 간선이 있습니다. 8자 모양 그래프는 크기가 동일한 2개의 도넛 모양 그래프에서 정점을 하나씩 골라 결합시킨 형태의 그래프입니다. 8자 모양 그래프의 형태는 다음과 같습니다.

![Imgur](https://i.imgur.com/CpZlDuc.png)

도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프가 여러 개 있습니다. 이 그래프들과 무관한 정점을 하나 생성한 뒤, 각 도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프의 임의의 정점 하나로 향하는 간선들을 연결했습니다.
그 후 각 정점에 서로 다른 번호를 매겼습니다.

이때 당신은 그래프의 간선 정보가 주어지면 생성한 정점의 번호와 정점을 생성하기 전 도넛 모양 그래프의 수, 막대 모양 그래프의 수, 8자 모양 그래프의 수를 구해야 합니다.

그래프의 간선 정보를 담은 2차원 정수 배열 `edges`가 매개변수로 주어집니다. 이때, 생성한 정점의 번호, 도넛 모양 그래프의 수, 막대 모양 그래프의 수, 8자 모양 그래프의 수를 순서대로 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요.
<br>

## **제한사항**
- 1 ≤ edges의 길이 ≤ 1,000,000
    - edges의 원소는 [a,b] 형태이며, a번 정점에서 b번 정점으로 향하는 간선이 있다는 것을 나타냅니다.
    - 1 ≤ a, b ≤ 1,000,000
- 문제의 조건에 맞는 그래프가 주어집니다.
- 도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프의 수의 합은 2 이상입니다.
<br>

## **체감 난이도**
🟩🟩🟩⬜⬜
<br>

## **풀이**
dfs로 풀어야 하나 어째야 하나 고민을 거듭했지만, 문제에 주어진 특성을 활용해 쉽게 풀어보자고 생각했고, 적중했다.

~~프로그래머스 문제 진짜.. 풀 때마다 괴롭다.~~

1. 이 그래프들과 무관한 정점을 하나 생성하여 각 그래프의 임의의 정점 하나로 향하는 간선을 연결한다면, 우선 이 정점, 즉 루트 노드를 찾아야 한다.
    - 도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프의 수의 합은 2 이상이므로, **루트 노드는 2 이상의 진출 간선만을** 가진다.
2. 막대 모양 그래프는 시작점과 마지막 점을 제외하고는 진출 간선 1개, 진입 간선이 1개이다.
    - 어차피 루트 정점에서 막대 모양 그래프의 임의의 정점으로 간선을 긋는다고 가정했을 때, 모든 것이 변할 수 있지만 마지막 정점에서 진출 노드가 없다는 것을 변화시킬 수는 없다.
    - 따라서 **진출 노드가 없는 정점을 찾으면 해당 그래프가 막대 그래프**이다.
3. 8자 모양 그래프는 크기가 동일한 2개의 도넛 모양 그래프에서 정점을 하나씩 골라 결합시킨 형태이다.
    - 따라서, **진출 간선이 2, 진입 간선도 2가 되는 정점**을 찾아야 한다. 다만, **8자 모양 그래프를 구성하는 특정 정점이 루트 노드에서의 진출 간선과 이어져 있다면 진입 간선의 개수는 3이 될 수도** 있다.
4. 도넛 모양 그래프는 좀 애매한 것이, 아무 정점에서 출발해도 결국은 다른 정점들을 한 번씩 방문한 이후 원래 출발했던 정점으로 돌아오게 된다.
    - 즉, 모든 정점의 진출 간선이 1, 진입 간선이 1이기 때문에 막대 모양 그래프나 8자 모양 그래프와 달리 특정 노드의 특징을 찾아 개수를 셀 수 없다.
    - 따라서 도넛 모양 그래프, 8자 모양 그래프의 개수를 구해 전체에서 빼 주는 방식으로 계산했다.
<br>

## **정답 코드**
```c++
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

// 노트 번호의 최댓값
int N;
// 진입 간선의 개수, 진출 간선의 개수
int come[1000001], go[1000001];

// 동벽 배열 answer의 크기는 4
// 각 원소는 인덱스 순으로 루트 노드, 도넛 모양 그래프의 개수, 막대 모양 그래프의 개수, 8자 모양 그래프의 개수를 의미한다.
vector<int> answer(4, 0);

// 루트 노드를 찾는 함수
void find_root()
{
    for (int i = 1; i <= N; i++)
        if (go[i] >= 2 && !come[i])
        {
            answer[0] = i;
            return;
        }
}

// 막대 모양 그래프를 구성하는지 확인하는 함수
// 특정 노드의 진출 노드의 개수가 0인지 확인한다.
bool is_stick(int node)
{
    return go[node] == 0;
}

// 8자 모양 그래프를 구성하는지 확인하는 함수
// 진출 노드가 2, 진입 노드가 2 혹은 3이 되는 정점을 찾는다.
bool is_eight(int node)
{
    return (come[node] == 2 || come[node] == 3) && go[node] == 2;
}

vector<int> solution(vector<vector<int>> edges)
{
    for (vector<int> v : edges)
    {
        go[v[0]]++;
        come[v[1]]++;
        N = max({N, v[0], v[1]});
    }
    
    find_root();
    
    for (int i = 1; i <= N; i++)
    {
        if (is_stick(i))
            answer[2]++;
        else if (is_eight(i))
            answer[3]++;
    }
    
    answer[1] = go[answer[0]] - answer[2] - answer[3];
    
    return answer;
}
```