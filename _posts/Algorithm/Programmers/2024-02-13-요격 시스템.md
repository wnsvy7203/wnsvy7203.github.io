---
title: "[프로그래머스] Lv.2 요격 시스템 (C++)"
date: 2024-02-13 00:39:00 +09:00
categories: [Algorithm, 프로그래머스]
tags: [Algorithm, 프로그래머스, C++, Lv.2]
---
## **문제**
[[연습문제] 요격 시스템](https://school.programmers.co.kr/learn/courses/30/lessons/181188)

A 나라가 B 나라를 침공하였습니다. B 나라의 대부분의 전략 자원은 아이기스 군사 기지에 집중되어 있기 때문에 A 나라는 B 나라의 아이기스 군사 기지에 융단폭격을 가했습니다.

A 나라의 공격에 대항하여 아이기스 군사 기지에서는 무수히 쏟아지는 폭격 미사일들을 요격하려고 합니다. 이곳에는 백발백중을 자랑하는 요격 시스템이 있지만 운용 비용이 상당하기 때문에 미사일을 최소로 사용해서 모든 폭격 미사일을 요격하려 합니다.

A 나라와 B 나라가 싸우고 있는 이 세계는 2 차원 공간으로 이루어져 있습니다. A 나라가 발사한 폭격 미사일은 x 축에 평행한 직선 형태의 모양이며 개구간을 나타내는 정수 쌍 (s, e) 형태로 표현됩니다. B 나라는 특정 x 좌표에서 y 축에 수평이 되도록 미사일을 발사하며, 발사된 미사일은 해당 x 좌표에 걸쳐있는 모든 폭격 미사일을 관통하여 한 번에 요격할 수 있습니다. 단, 개구간 (s, e)로 표현되는 폭격 미사일은 s와 e에서 발사하는 요격 미사일로는 요격할 수 없습니다. 요격 미사일은 실수인 x 좌표에서도 발사할 수 있습니다.

각 폭격 미사일의 x 좌표 범위 목록 `targets`이 매개변수로 주어질 때, 모든 폭격 미사일을 요격하기 위해 필요한 요격 미사일 수의 최솟값을 return 하도록 solution 함수를 완성해 주세요.
<br>

## **제한사항**
- 1 ≤ `targets`의 길이 ≤ 500,000
- targets의 각 행은 [s,e] 형태입니다.
    - 이는 한 폭격 미사일의 x 좌표 범위를 나타내며, 개구간 (s, e)에서 요격해야 합니다.
    - 0 ≤ s < e ≤ 100,000,000
<br>

## **체감 난이도**
🟩🟩⬜⬜⬜
<br>

## **풀이**
주의해야 할 조건으로는, **개구간 (s, e)으로 표현되는 폭격 미사일을 s 혹은 e에서 발사하는 요격 미사일로 요격할 수 없다**는 것이다.

찾아야 할 정답은, x축에 평행하도록 주어진 직선들을 모두 관통하는 y축에 평행하는 직선의 최소 개수이다.

1. 주어진 `targets`를 오름차순 정렬하는데, 오른쪽 끝점을 기준으로 정렬한다. 오른쪽 끝점에 붙여서 요격해야 뒤쪽의 타겟들에 최대한 많이 걸치도록 구현할 수 있기 때문이다.
2. `now` 변수는 마지막으로 쏜 요격점 `e`를 의미한다. 초깃값은 개구간의 특성을 감안하여 0으로 잡는다. `now`가 `int`값을 갖지만, 개구간의 특성상 실제로 요격한 지점은 `e`보다 작고 `e-1`보다 큰 `double` 값 어딘가를 의미한다고 생각하면 편하다.
3. 만약 새로운 타겟의 시작점이 마지막 요격점보다 뒤에 있다면, 현재 쏜 요격 미사일들로는 요격할 수 없다는 뜻이므로 새로 요격해야 한다. 즉, **반복문을 순회하면서 만약 `now`가 다음 개구간의 왼쪽 끝점보다 작거나 같다면 새로운 미사일이 필요하다.**
<br>

## **정답 코드**
```c++
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int ans;

bool cmp(vector<int> a, vector<int> b)
{
    if (a[0] == b[0])
        return a[0] < b[0];

    return a[1] < b[1];
}

int solution(vector<vector<int>> targets) {
    sort(targets.begin(), targets.end(), cmp);
    
    int now = 0;
    
    for (vector<int> target : targets)
    {
        int s = target[0];
        int e = target[1];
        
        // 현재 쏜 요격점을 now라고 봤을 때, now가 정수이지만 해당 정수보다 작은 실수 어딘가를 요격했다는 뜻이다.
        if (now <= s)
        {
            ans++;
            now = e;
        }
    }
    
    return ans;
}
```