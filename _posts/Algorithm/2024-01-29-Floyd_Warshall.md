---
title: "[Algorithm] Floyd Warshall(플로이드-워셜)"
date: 2024-01-29 02:48:00 +09:00
categories: [Algorithm, Problem Solving(PS)]
tags: [Algorithm, C++, 그래프 이론, 최소 스패닝 트리]
---
## **1. 개요**
모든 정점에서 다른 정점으로의 최단 경로를 한 번에 구하는 알고리즘

다익스트라가 하나의 정점, 즉, 시작점을 잡은 이후 다른 모든 정점까지의 최단 거리를 구하는 알고리즘이었다면, 플로이드-워셜은 단 한 번의 알고리즘 실행으로 모든 정점에서 다른 모든 정점으로의 최단 경로를 구할 수 있다.

또다른 점이 있다면, 다익스트라와는 다르게 음의 간선도 사용할 수 있다.
<br>

## **2. 알고리즘**
모든 쌍을 표현하는 2차원 배열을 선언하고 초기화해준다.
특정 정점 i에서 i로 가는 최소비용은 움직이지 않는 것이므로, 그 이상 업데이트할 필요가 없고, 다른 정점으로 가는 비용은 주어진 범위 내에서 만들 수 있는 최댓값으로 초기화해주면 된다.
```c++
void init()
{
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (i == j)
                graph[i][j] = 0;
            else
                graph[i][j] = 2e9;
}
```
최소 비용을 업데이트하는 것이므로, 위의 보기에서는 `2e9`에서부터 출발하여, 알고리즘이 진행되면서 업데이트되도록 만들어주면 된다.

```c++
void floyd()
{
    // i -> j로 가는 최단 거리를 구하는데, 
    // 중간에 거치는 정점이 k라고 했을 때, i -> k -> j의 비용이 더 적게 들면 업데이트해주는 방식으로 진행된다.
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);
}
```
위의 코드가 기본적인 플로이드-워셜을 진행하는 코드이다. i -> j로 가는 최단 거리를 구한다는 것을 가정하고, k라는 정점을 거칠 때, i -> j로 가는 것보다 i -> k -> j의 경로의 비용이 더 적다면(즉, 특정 정점을 경유하는 것이 최단이라면), 해당 정점 k를 거쳐 가도록 업데이트 해 나가는 방식이다. 

이런 방식으로 업데이트가 진행되면, 모든 정점에서부터 모든 정점까지로의 최단 경로를 확인해야 알고리즘이 끝나게 되므로, 시간 복잡도는 `O(V^3)`이다(V: 정점의 개수).
<br>

## **3. BOJ_11404 플로이드**
제목이 곧 내용이 되는, 플로이드-워셜의 기본적인 문제이다. 2차원 인접 행렬 전체를 전부 출력하면 되는 문제이니, 풀이를 잘 들여다보면 플로이드-워셜의 구현 방법을 이해할 수 있을 것이다.

문제의 풀이는 아래를 참고하면 되겠다.
> [BOJ_11404. 플로이드](https://wnsvy7203.github.io/posts/11404/)