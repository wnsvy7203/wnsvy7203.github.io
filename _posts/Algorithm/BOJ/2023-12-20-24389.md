---
title: "[BOJ] 24389. 2의 보수 (C++)"
date: 2023-12-20 19:56:00 +09:00
categories: [Algorithm, BOJ]
tags: [Algorithm, BOJ, C++, 수학, 비트마스킹, Bronze 1]
---
## **문제**
[acmicpc.net/problem/24389](https://www.acmicpc.net/problem/24389)
<br>

컴퓨터는 뺄셈을 처리할 때 내부적으로 2의 보수를 사용한다. 어떤 수의 2의 보수는 해당하는 숫자의 모든 비트를 반전시킨 뒤, 1을 더해 만들 수 있다. 이때, 32비트 기준으로 처음 표현했던 수와 그 2의 보수의 서로 다른 비트 수를 출력하라.
<br>

## **입력**
첫째 줄에 정수 N(1 ≤ N ≤ 10<sub>9</sub>)이 주어진다.
<br>

## **출력**
첫째 줄에 N과 N의 보수의 서로 다른 비트 수를 출력한다.
<br>

## **힌트**
32비트 22의 보수를 살펴보자. 22는 이진수로 0000 0000 0000 0000 0000 0000 0001 0110이다. 이 비트를 반전시키면 1111 1111 1111 1111 1111 1111 1110 1001, 1을 더하면 1111 1111 1111 1111 1111 1111 1110 1010이 된다.

이 때 0000 0000 0000 0000 0000 0000 0001 0110과 1111 1111 1111 1111 1111 1111 1110 1010의 서로 다른 비트 수는 30개이다.
<br>

## **체감 난이도**
🟩⬜⬜⬜⬜
<br>

## **풀이**
어떤 수의 2의 보수는, 해당하는 숫자의 모든 비트를 반전시킨 뒤, 1을 더해 만들 수 있다고 되어 있다. 그렇지만 더 간단하게 표현하면, C의 정수 자료형에서 1 이상의 자연수 N의 2의 보수는 -N과 같다.

`N`과 `~N+1`을 비교하든, `N`과 `-N`을 비교하든 답은 똑같이 나온다. 다만, 자연수 N의 2의 보수가 -N과 같다는 것은 참고해 둘 부분이다.
<br>

## **정답 코드**
```c++
#include <iostream>

using namespace std;

int N, M;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> N;
    M = (~N + 1);
    int cnt = 0;
    for (int i = 0; i < 32; i++)
    {
        if ((M & 1) != (N & 1))
            cnt++;
        N >>= 1;
        M >>= 1;
    }

    cout << cnt;
}
```