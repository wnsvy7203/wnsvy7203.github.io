---
title: "[BOJ] 29702. 이상한 호텔의 송이"
date: 2023-12-26 20:51:00 +09:00
categories: [Algorithm, BOJ]
tags: [Algorithm, BOJ, C++, 수학, 비트마스킹, Silver 4]
---
## **문제**
[acmicpc.net/problem/29702](https://www.acmicpc.net/problem/29702)
<br>

송이가 묵고 있는 S 호텔은 60층짜리 건물인데, 이 호텔의 구조는 완전 이진 트리의 형태로 나타낼 수 있다. 호텔에 있는 방들을 트리의 노드로, 방과 방 사이를 위아래로 잇는 계단을 간선으로 생각한다면, 이 호텔의 구조는 가장 꼭대기에 루트 노드가 있는 완전 이진 트리의 형태이다. 이때, 방과 방 사이를 이동하기 위해서는 두 방 사이를 잇는 계단이 존재해야 하며 계단을 통해서만 이동이 가능하다.

다음 그림은 이 호텔의 1층부터 3층 사이에 존재하는 방과 계단을 나타낸 것이다. 그림에서 직사각형으로 표현된 노드는 방이고 방과 방을 잇는 선은 계단을 의미한다. 직사각형 안에 쓰여있는 수는 그 방의 호수이다. 또, 파란색 사각형 안의 수는 호텔에 있는 모든 방을 호수를 기준으로 오름차순 정렬했을 때 몇 번째로 오는지를 나타내는 수이다.

이 호텔은 특이하게도 가장 꼭대기 층이 1층이고, 아래로 내려올수록 층의 번호가 1씩 증가하여 가장 아래쪽 층은 60층이다. 완전 이진 트리 구조를 갖는 이 호텔에는, 1층에 1개의 방이, 1층을 제외한 나머지 층에는 층마다 바로 위층에 존재하는 방 개수의 두 배만큼의 방이 존재한다.

이 호텔의 각 층에는 방마다 번호가 붙어 있다. 각 층의 방 번호는 1부터 시작해서 1씩 증가하여, 그 층의 가장 마지막 방의 방 번호는 해당 층에 존재하는 방의 개수와 같다. 또, 1층을 제외한 각 층의 i번 방은 바로 위층의 i/2번 방과 계단으로 연결되어 있다. 예시로 3층 3번 방은 2층 2번 방과 계단으로 연결되어 있다는 사실을 위의 그림에서 확인할 수 있다.

이 호텔의 각 방의 호수는, 그 방이 위치하는 층의 번호와 해당 층에서 그 방의 번호를 이어 붙인 수이다. 이때, 방 번호가 18자리보다 더 작은 자리의 수라면, 
18자리가 되도록 앞에 0을 붙인 뒤 층수와 이어 붙인다. 예를 들면 3층의 가장 마지막 방은 3,000,000,000,000,000,004호이다.

길치인 송이는 지금 이 호텔에 존재하는 모든 방의 호수를 오름차순으로 정렬했을 때 N번째 방에 있다. 송이는 호텔 전망대가 있는 1층 1번 방으로 최소한의 방만을 거쳐서 이동하려고 한다. 송이가 전망대까지 이동하기 위해 지나야 하는 방들의 호수를 모두 출력하여 송이를 무사히 전망대까지 데려다주자.
<br>

## **입력**
첫째 줄에 테스트 케이스의 수 T가 주어진다. (1 ≤ T ≤ 10<sup>4</sup>)

각 테스트 케이스마다 현재 송이가 있는 방의 위치를 나타내는 N이 한 줄에 하나씩 주어진다. (2 ≤ N ≤ 10<sup>18</sup>)

송이는 현재 호텔에 존재하는 모든 방의 호수를 오름차순으로 정렬했을 때 
N번째로 오는 방에 있다.
<br>

## **출력**
각 테스트 케이스마다 현재 송이가 있는 방과 전망대 방을 포함하여 송이가 지나야 하는 방의 호수를 한 줄에 하나씩 차례대로 출력한다.

단, 한 테스트 케이스 내에서 송이가 한 번 지나갔던 방을 다시 지나가서는 안된다.
<br>

## **힌트**
그래프 이론에서 트리란, 사이클이 없는 연결 그래프를 의미한다. 트리 중에서도 특별히 다음 두 조건을 만족하는 트리를 완전 이진 트리라고 말한다.

- 리프 노드(잎 노드)를 제외한 모든 노드들은 정확히 두 개의 자식 노드를 갖는다.
- 리프 노드들의 깊이는 모두 동일하다. (단, 트리에서 어떤 노드의 깊이란, 그 노드로부터 루트 노드까지 도달하는 데에 필요한 간선의 최소 개수로 정의된다.)
<br>

## **체감 난이도**
🟩🟩⬜⬜⬜
<br>

## **풀이**
주어진 힌트대로, 완전 이진 트리에서 루트 노드를 찾아가면서 방문하게 되는 모든 노드들을 주어진대로 모두 출력하면 되는 문제이다.

1. 주어진 N이 몇 층인지부터 구한다.
2. 주어진 층에서 몇 번째 방인지를 구한다.
3. 1번과 2번의 결과를 `string`으로 만든 이후, '0'을 2번 결과의 길이가 총 18자리가 되도록 출력한다.
<br>

## **정답 코드**
```c++
// 268ms

#include <iostream>
#include <string>

using namespace std;

int T;
long long N;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> T;
    while (T--)
    {
        cin >> N;
        int floor = 0;

        // N이 몇 층인지 구하는 로직
        // floor: 층 수
        for (int i = 59; i >= 0; i--)
        {
            if ((N >> i) & 1)
            {
                floor = i+1;
                break;
            }
        }

        while (N)
        {
            // 요구되는 출력에 따라 우선 현재 몇 층인지 출력
            cout << floor;
            floor--;

            // 1 << k 는 32비트, 1LL << k 해야 64비트까지 넘어간다는 것을 유의할 것
            // room은 해당 floor에서 몇 번째 방인지를 의미하는 변수
            long long room = N - (1LL << floor) + 1;

            // 0의 개수와 room의 길이가 총 18자리가 되어야 한다.
            int len = to_string(room).length();

            // 18-len만큼 0 출력
            for (int i = 1; i <= 18-len; i++)
                cout << '0';
            
            cout << room << '\n';
            // 완전 이진 트리의 성질에 따라 N >>= 1
            N >>= 1;
        }
    }
}
```