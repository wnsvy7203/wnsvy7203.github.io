---
title: "[BOJ] 1987. 알파벳 (C++)"
date: 2023-11-13 13:53:00 +09:00
categories: [Algorithm, BOJ]
tags: [Algorithm, BOJ, C++, 그래프 이론, 그래프 탐색, 깊이 우선 탐색, 백트래킹, Gold 4, CLASS 4]
---
## **문제**
[acmicpc.net/problem/1987](https://www.acmicpc.net/problem/1987)
<br>

세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (1행 1열) 에는 말이 놓여 있다.

말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.

좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.
<br>

## **입력**
첫째 줄에 R과 C가 빈칸을 사이에 두고 주어진다. (1 ≤ R, C ≤ 20) 둘째 줄부터 R개의 줄에 걸쳐서 보드에 적혀 있는 C개의 대문자 알파벳들이 빈칸 없이 주어진다.
<br>

## **출력**
첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다.
<br>

## **체감 난이도**
🟩🟩⬜⬜⬜
<br>

## **풀이**
백트래킹에 대한 이해는 늘 부족한 것 같다. 현재 상태에서 가능한 모든 경로를 따라 들어가 탐색하다가, **원하는 값이 아니라면 이전까지 왔던 길을 되짚어 돌아가는,** 해당 방식을 구현하면 되는 문제이다.

가능한 모든 경로를 따라 들어간다는 점에서 백트래킹은, 알고리즘 문제에서는 보통 경우의 수를 구하는 것을 요구하게 되므로 대부분 깊이 우선 탐색(dfs)로 구한다.

알고리즘 자체는 단순하지만, 기본적인 알고리즘에서 벗어나서 생각이 필요한 단계가 되는 경우가 있기 때문에 단순히 구현하는 것보다 많은 문제를 풀어보면서 연습하는 과정이 꼭 필요하겠다.
<br>

## **정답 코드**
```c++
// 424ms

#include <iostream>

using namespace std;

int R, C;
string str;
char board[20][20];

int dr[4] = {-1, 1, 0, 0};
int dc[4] = {0, 0, -1, 1};
bool visited[26];

int ans;
// 백트래킹 알고리즘
void dfs(int r, int c, int cnt)
{
    // 백트래킹이 도달한 최대 깊이(depth)가 정답이다.
    ans = max(ans, cnt);
    for (int d = 0; d < 4; d++)
    {
        // 이동할 수 있는 방향은 주어진대로 4방향
        int nr = r + dr[d];
        int nc = c + dc[d];

        // board의 범위를 벗어난 경우는 당연히 건너뛰고
        if (nr < 0 || nr >= R || nc < 0 || nc >= C)
            continue;
        
        // 다음 갈 수 있는 곳이 아직 방문하기 전인 곳이라면
        if (!visited[board[nr][nc]-65])
        {
            // 방문 표시를 해 주고
            visited[board[nr][nc]-65] = 1;
            // 한 단계 진행하고
            dfs(nr, nc, cnt+1);
            // 걸리는 부분에서 다시 돌아나와야 한다. 돌아나온 이후에는 방문 표시를 다시 취소해줘야 다음 단계에서 다시 방문할 수 있다.
            visited[board[nr][nc]-65] = 0;
        }
    }
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> R >> C;
    for (int i = 0; i < R; i++)
    {
        cin >> str;
        for (int j = 0; j < C; j++)
            board[i][j] = str[j];
    }
    
    visited[board[0][0]-65] = 1;
    dfs(0, 0, 1);
    cout << ans;
}
```