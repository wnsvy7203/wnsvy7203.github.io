---
title: "[BOJ] 11660. 구간 합 구하기 5 (C++)"
date: 2023-11-06 00:07:00 +09:00
categories: [Algorithm, BOJ]
tags: [Algorithm, BOJ, C++, 다이나믹 프로그래밍, Silver 1, CLASS 4]
---
## **문제**
[acmicpc.net/problem/11660](https://www.acmicpc.net/problem/11660)
<br>

N×N개의 수가 N×N 크기의 표에 채워져 있다. (x1, y1)부터 (x2, y2)까지 합을 구하는 프로그램을 작성하시오. (x, y)는 x행 y열을 의미한다.

예를 들어, N = 4이고, 표가 아래와 같이 채워져 있는 경우를 살펴보자.

|:--:|:--:|:--:|:--:|
|1|2|3|4|
|2|3|4|5|
|3|4|5|6|
|4|5|6|7|

여기서 (2, 2)부터 (3, 4)까지 합을 구하면 3+4+5+4+5+6 = 27이고, (4, 4)부터 (4, 4)까지 합을 구하면 7이다.

표에 채워져 있는 수와 합을 구하는 연산이 주어졌을 때, 이를 처리하는 프로그램을 작성하시오.
<br>

## **입력**
첫째 줄에 표의 크기 N과 합을 구해야 하는 횟수 M이 주어진다. (1 ≤ N ≤ 1024, 1 ≤ M ≤ 100,000) 둘째 줄부터 N개의 줄에는 표에 채워져 있는 수가 1행부터 차례대로 주어진다. 다음 M개의 줄에는 네 개의 정수 x1, y1, x2, y2 가 주어지며, (x1, y1)부터 (x2, y2)의 합을 구해 출력해야 한다. 표에 채워져 있는 수는 1,000보다 작거나 같은 자연수이다. (x1 ≤ x2, y1 ≤ y2)
<br>

## **출력**
총 M줄에 걸쳐 (x1, y1)부터 (x2, y2)까지 합을 구해 출력한다.
<br>

## **체감 난이도**
🟩⬜⬜⬜⬜
<br>

## **풀이**
알고리즘 문제를 풀 때 문제에서 주어지는 변수를 그대로 쓰는 것을 선호하는데, x1, y1 등이 c++ 예약어라 사용할 수 없다는 것이 아주 불편하게 느껴진다. x1, y1을 변수로 주는 문제가 생각보다 많다...

생각해보면 어렵지 않게 풀 수 있는 dp 문제이다.

여러 차례의 연산이 이루어져야 하기 때문에 까다롭게 느껴질 수 있지만, 결국은 한 번의 연산을 통해 dp 배열을 채워놓고, while 문을 돌면서 M번만큼 주어지는 x1, y1, x2, y2를 활용해서 주어진 범위의 합을 구하면 된다.

주어진 예시를 기준으로 설명해보자면, 주어진 배열 `nums`는

|:--:|:--:|:--:|:--:|
|1|2|3|4|
|2|3|4|5|
|3|4|5|6|
|4|5|6|7|

만들어지게 되는 dp 배열은

|:--:|:--:|:--:|:--:|
|1|3|6|10|
|3|8|15|24|
|6|15|27|42|
|10|24|42|64|

여기서 뽑아낼 수 있는 dp 배열의 일반 점화식은, **`dp[i][j] = nums[i][j] + dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]`**이다.

이제 여기서 주어진 구간의 합을 구해주면 되는데, 예시처럼 (2, 2)부터 (3, 4) 까지의 합을 구한다고 했을 때, (1, 1)에서부터 (1, 4)까지의 합은 필요없고, 역시 (1, 1)에서부터 (3, 1)까지의 합은 필요가 없다.

따라서 이 둘을 뺀 값을 구해주면 되는데, 주의해야 할 점은 **2번 빼 준 (1, 1)을 한 번 더해줘야 한다는 것**이다.

이 역시 식을 일반화 해 보면 **`dp[r2][c2] - dp[r1-1][c2] - dp[r2][c1-1] + dp[r1-1][c1-1]`**이 된다.

결국 이 과정을 M번 반복한 값을 출력해주기만 하면 되는 문제이다.
<br>

## **정답 코드**
```c++
// 128ms

#include <iostream>

using namespace std;

int N, M;
int nums[1025][1025], dp[1025][1025];
int r1, c1, r2, c2;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> N >> M;
    for (int i = 1; i <= N; i++)
        for (int j = 1; j <= N; j++)
            cin >> nums[i][j];

    for (int i = 1; i <= N; i++)
        for (int j = 1; j <= N; j++)
            dp[i][j] = nums[i][j] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1];
    
    while (M--)
    {
        cin >> r1 >> c1 >> r2 >> c2;

        cout << dp[r2][c2] - dp[r1-1][c2] - dp[r2][c1-1] + dp[r1-1][c1-1] << '\n';
    }
}
```