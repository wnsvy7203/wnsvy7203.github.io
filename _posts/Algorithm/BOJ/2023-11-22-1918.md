---
title: "[BOJ] 1918. 후위 표기식 (C++)"
date: 2023-11-22 21:58:00 +09:00
categories: [Algorithm, BOJ]
tags: [Algorithm, BOJ, C++, 자료 구조, 스택, Gold 2, CLASS 4]
---
## **문제**
[acmicpc.net/problem/1918](https://www.acmicpc.net/problem/1918)
<br>

수식은 일반적으로 3가지 표기법으로 표현할 수 있다. 연산자가 피연산자 가운데 위치하는 중위 표기법(일반적으로 우리가 쓰는 방법이다), 연산자가 피연산자 앞에 위치하는 전위 표기법(prefix notation), 연산자가 피연산자 뒤에 위치하는 후위 표기법(postfix notation)이 그것이다. 예를 들어 중위 표기법으로 표현된 `a+b`는 전위 표기법으로는 `+ab`이고, 후위 표기법으로는 `ab+`가 된다.

이 문제에서 우리가 다룰 표기법은 후위 표기법이다. 후위 표기법은 위에서 말한 법과 같이 연산자가 피연산자 뒤에 위치하는 방법이다. 이 방법의 장점은 다음과 같다. 우리가 흔히 쓰는 중위 표기식 같은 경우에는 덧셈과 곱셈의 우선순위에 차이가 있어 왼쪽부터 차례로 계산할 수 없지만 후위 표기식을 사용하면 순서를 적절히 조절하여 순서를 정해줄 수 있다. 또한 같은 방법으로 괄호 등도 필요 없게 된다. 예를 들어 `a+b*c`를 후위 표기식으로 바꾸면 `abc*+`가 된다.

중위 표기식을 후위 표기식으로 바꾸는 방법을 간단히 설명하면 이렇다. 우선 주어진 중위 표기식을 연산자의 우선순위에 따라 괄호로 묶어준다. 그런 다음에 괄호 안의 연산자를 괄호의 오른쪽으로 옮겨주면 된다.

예를 들어 `a+b*c`는 `(a+(b*c))`의 식과 같게 된다. 그 다음에 안에 있는 괄호의 연산자 `*`를 괄호 밖으로 꺼내게 되면 `(a+bc*)`가 된다. 마지막으로 또 `+`를 괄호의 오른쪽으로 고치면 `abc*+`가 되게 된다.

다른 예를 들어 그림으로 표현하면 `A+B*C-D/E`를 완전하게 괄호로 묶고 연산자를 이동시킬 장소를 표시하면 다음과 같이 된다.

![Imgur](https://i.imgur.com/71JAikn.png)
결과: `ABC*+DE/-`

이러한 사실을 알고 중위 표기식이 주어졌을 때 후위 표기식으로 고치는 프로그램을 작성하시오.
<br>

## **입력**
첫째 줄에 중위 표기식이 주어진다. 단 이 수식의 피연산자는 알파벳 대문자로 이루어지며 수식에서 한 번씩만 등장한다. 그리고 `-A+B`와 같이 `-`가 가장 앞에 오거나 AB와 같이 `*`가 생략되는 등의 수식은 주어지지 않는다. 표기식은 알파벳 대문자와 `+`, `-`, `*`, `/`, `(`, `)`로만 이루어져 있으며, 길이는 100을 넘지 않는다. 
<br>

## **출력**
첫째 줄에 후위 표기식으로 바뀐 식을 출력하시오
<br>

## **체감 난이도**
🟩🟩⬜⬜⬜
<br>

## **풀이**
중위 표기식을 후위 표기식으로 변환하는 문제이다. 후위 표기식의 표현법을 제대로 이해하는 것이 중요한 문제였다.

1. 사칙연산과 괄호로만 이루어진 연산이므로 연산자의 우선순위는 괄호 안의 계산 -> 곱셈, 나눗셈 -> 덧셈, 뺄셈 순으로 정리할 수 있다.
2. 반복문을 돌면서 알파벳(피연산자)일 때는 바로 출력하면 된다.
3. 연산자는 `stack` 안에 쌓아가면서 진행한다.
    - `stack`의 `top`이 자신보다 우선순위가 낮은 연산자를 만날 때까지 `pop` 하고 자신을 담는다.
    - 즉, 덧셈이나 뺄셈은 여는 괄호를 만나기 전부 출력하고 `pop`한 후 자신을 담는다.
    - 곱셈이나 나눗셈은 `top`이 곱셈이나 나눗셈인 경우에만 출력하고 `pop`한 이후 자신을 담는다.
    - 여는 괄호일 때는 `stack`에 쌓고, 닫는 괄호가 나온 경우 여는 괄호가 나올 때까지 모두 출력하고 `pop`한다.
    - 마지막에는 `stack`에 남은 모든 원소를 출력하고 `pop`한다.
<br>

## **정답 코드**
```c++
#include <iostream>
#include <stack>

using namespace std;

string str;
stack<char> cal;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> str;

    for (int i = 0; i < str.size(); i++)
        if (str[i] >= 65 && str[i] <= 90)
            cout << str[i];
        // 닫는 괄호
        else if (str[i] == ')')
        {
            while (cal.top() != '(')
            {
                cout << cal.top();
                cal.pop();
            }

            // 마지막 남은 여는 괄호를 pop 한다.
            cal.pop();
        }
        // 곱셈, 나눗셈
        else if (str[i] == '*' || str[i] == '/')
        {
            while (!cal.empty() && (cal.top() == '*' || cal.top() == '/'))
            {
                cout << cal.top();
                cal.pop();
            }
            cal.push(str[i]);
        }
        // 덧셈, 뺄셈
        else if (str[i] == '+' || str[i] == '-')
        {
            while (!cal.empty() && cal.top() != '(')
            {
                cout << cal.top();
                cal.pop();
            }
            cal.push(str[i]);
        }
        else
            cal.push(str[i]);
    
    while (!cal.empty())
    {
        cout << cal.top();
        cal.pop();
    }
}
```