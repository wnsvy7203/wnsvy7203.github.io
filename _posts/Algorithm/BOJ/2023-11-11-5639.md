---
title: "[BOJ] 5639. 이진 검색 트리 (C++)"
date: 2023-11-11 20:40:00 +09:00
categories: [Algorithm, BOJ]
tags: [Algorithm, BOJ, C++, 그래프 이론, 그래프 탐색, 트리, 재귀, Gold 4, CLASS 4]
---
## **문제**
[acmicpc.net/problem/5639](https://www.acmicpc.net/problem/5639)
<br>

이진 검색 트리는 다음과 같은 세 가지 조건을 만족하는 이진 트리이다.

- 노드의 왼쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 작다.
- 노드의 오른쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 크다.
- 왼쪽, 오른쪽 서브트리도 이진 검색 트리이다.

![Imgur](https://i.imgur.com/Mqlf0qI.png)

전위 순회 (루트-왼쪽-오른쪽)은 루트를 방문하고, 왼쪽 서브트리, 오른쪽 서브 트리를 순서대로 방문하면서 노드의 키를 출력한다. 후위 순회 (왼쪽-오른쪽-루트)는 왼쪽 서브트리, 오른쪽 서브트리, 루트 노드 순서대로 키를 출력한다. 예를 들어, 위의 이진 검색 트리의 전위 순회 결과는 50 30 24 5 28 45 98 52 60 이고, 후위 순회 결과는 5 28 24 45 30 60 52 98 50 이다.

이진 검색 트리를 전위 순회한 결과가 주어졌을 때, 이 트리를 후위 순회한 결과를 구하는 프로그램을 작성하시오.
<br>

## **입력**
트리를 전위 순회한 결과가 주어진다. 노드에 들어있는 키의 값은 10<sup>6</sup>보다 작은 양의 정수이다. 모든 값은 한 줄에 하나씩 주어지며, 노드의 수는 10,000개 이하이다. 같은 키를 가지는 노드는 없다.
<br>

## **출력**
입력으로 주어진 이진 검색 트리를 후위 순회한 결과를 한 줄에 하나씩 출력한다.
<br>

## **체감 난이도**
🟩🟩⬜⬜⬜
<br>

## **풀이**
후위 순회가 왼쪽 서브트리-오른쪽 서브트리-루트 순으로 순회하는 구조임을 알고, 이진 검색 트리의 3가지 조건을 이해했다면 크게 어려운 문제는 아니다.

**1번과 2번의 조건에 따라 반드시 왼쪽 서브트리의 키보다 루트 노드의 키가 더 크고, 루트 노드의 키보다 오른쪽 서브트리의 키가 더 크다.**

트리를 전위 순회한 결과가 입력값으로 주어지면 모든 키 값을 동적 배열에 저장하고, 해당 배열의 인덱스를 활용해서 후위 순회를 진행한다.

만약, 시작점에서 출발해서 인덱스를 하나씩 늘려가면서 순회하다가 특정 노드의 키 값이 시작점의 키 값보다 작다면 거기서 멈추고, 그 인덱스를 기준으로 후위순회를 반복하는 재귀함수를 실행한다.

후위순회의 특성상, 왼쪽 - 오른쪽 - 루트를 순회해야 하므로, 먼저 왼쪽 서브트리를 순회하고, 오른쪽 서브트리를 순회한 이후, 루트 노드의 키 값을 출력하도록 하면 무리없이 문제가 해결된다.
<br>

## **정답 코드**
```c++
// 28ms

#include <iostream>
#include <vector>

using namespace std;

int n;
vector<int> pre;

void post(int s, int e)
{
    if (s > e)
        return;
    
    int m = e+1;

    for (int i = s+1; i <= e; i++)
        // 1번과 2번의 조건에 따라, 반드시 왼쪽 서브트리 < 루트 < 오른쪽 서브트리 순으로 키 값이 정해져야 한다.
        // 만약 해당 조건을 벗어났다면 해당 인덱스에서 멈추고,
        if (pre[s] < pre[i])
        {
            m = i;
            break;
        }
    
    // 멈춘 인덱스를 기준으로 후위 순회를 반복한다.
    post(s+1, m-1);
    post(m, e);
    cout << pre[s] << '\n';
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    while (cin >> n)
        pre.push_back(n);
    
    post(0, pre.size()-1);
}
```