---
title: "[BOJ(C++)] 9527. 1의 개수 세기"
date: 2024-02-10 19:10:00 +09:00
categories: [Algorithm, BOJ]
tags: [Algorithm, BOJ, C++, 수학, 누적 합, 비트마스킹, Gold 2, CLASS 5]
use_math: true
---
## **문제**
[acmicpc.net/problem/9527](https://www.acmicpc.net/problem/9527)

두 자연수 A, B가 주어졌을 때, A ≤ x ≤ B를 만족하는 모든 x에 대해 x를 이진수로 표현했을 때 1의 개수의 합을 구하는 프로그램을 작성하시오.

즉, f(x) = x를 이진수로 표현 했을 때 1의 개수라고 정의하고, 아래 식의 결과를 구하자.

$\sum_{i=A}^{B} f(i)$
<br>

## **입력**
첫 줄에 두 자연수 A, B가 주어진다. (1 ≤ A ≤ B ≤ 10<sup>16</sup>)
<br>

## **출력**
1의 개수를 세어 출력한다.
<br>

## **체감 난이도**
🟩🟩🟩⬜⬜
<br>

## **풀이**
문제 자체는 이해하는 데 어렵진 않지만, 어떻게 풀어야 할 지 고민해야 하는 문제였다. 대충 생각해도 단순히 1의 개수를 세면 시간 초과가 날 게 뻔했다. 따라서 이진수의 특성상 X2 한다는 것은 비트를 한 칸 미는 것과 같은 효과를 주므로, 어떤 자연수를 X2 한 이후의 1의 개수는 2를 곱하기 전과 반드시 같다.
> ex. 1 -> 2 -> 4 -> 8 -> 16에서 1의 개수는 모두 1로 같다.

boolean 배열을 활용하여 visited 표시를 해 가면서 문제를 풀려고 했지만, boolean 배열의 크기 때문에 메모리 초과가 발생했다.

그래서 <u>문제의 알고리즘 분류</u>를 보고 다시 생각한 방법은, **누적합과 비트마스킹을 활용하여 1부터 B까지의 1의 개수 총합에서 1부터 A-1까지의 1의 개수 총합을 빼 준다면** A부터 B까지의 1의 개수의 총합을 출력할 수 있지 않을까 하는 것이었다.

정답 코드에 선언한 dp 배열을 선언한 이유는, 연산의 횟수를 최대한 줄이기 위해서이다. 아래의 그림에서 살펴보면, 1->2->4->8 까지 자릿수가 늘어날 때마다 일정한 규칙을 가진다. i번째 테이블은 이진수의 패턴상 i-1번째 테이블을 반드시 한 번 포함하게 된다. 빨간색 동그라미가 앞선 패턴이 한 번 더 반복됨을 의미하고, 검은색 네모는 테이블의 원소 개수만큼 1이 더해져야 함을 의미한다.

결국 정리하면, **dp[i] = 2 * dp[i-1] + 2<sup>i</sup>**가 성립함을 알 수 있다.

![Imgur](https://i.imgur.com/QHuPxXu.jpg)

다음의 규칙을 활용하여 예제에서처럼 2에서 12까지의 1의 개수를 구하는 경우에, 앞선 아이디어에 따라 1부터 12까지의 1의 개수를 구하여 1을 빼는 방식으로 구현한다고 가정해보자.

1. `long long`의 범위는 2<sup>63</sup>-1까지이므로, i가 63인 경우에서부터 반복문을 순회하여 현재 수 `12 & (1LL << i)` 인 i를 찾는다.
2. 12의 경우 i는 3에서 걸리는데, dp[2]에 1부터 7까지의 1의 개수가 저장되어 있고, 8부터 12까지 2<sup>3</sup> 자리가 모두 1이므로, 우선 5를 더하여 `res`에 `dp[2] + 12 - (1LL & 3) + 1`을 더한다.
3. `12 -= (1LL & 3)` 하여 남은 1에서부터 4까지 갖고 있는 1의 개수를 또 구한다. 즉, 1, 2의 과정을 반복하여 모든 과정이 마무리되었을 때의 `res`가 1부터 12까지의 1의 개수가 된다.
4. A-1, 즉 1을 가지고 같은 과정을 반복한 이후, 1부터 12까지의 1의 개수에서 1부터 1까지의 1의 개수를 빼 주면 정답이 된다.

~~설명해놓고 나니까 풀이가 무슨 말인지 잘 요약이 안 되는 느낌인데..~~
<br>

## **정답 코드**
```c++
#include <iostream>

using namespace std;

long long A, B, ans;
long long dp[63];

// n까지의 1의 개수를 구하는 함수
long long one(long long n)
{
    long long res = n & 1;
    for (int i = 63; i > 0; i--)
        if (n & (1LL << i))
        {
            res += dp[i-1] + (n - (1LL << i) + 1);
            n -= 1LL << i;
        }
    
    return res;
}

// 각 테이블의 1의 개수의 누적합을 구하는 문제
void dynamic()
{
    dp[0] = 1;
    for (int i = 1; i < 63; i++)
        dp[i] = dp[i-1] * 2 + (1LL << i);
}

void init()
{
    cin >> A >> B;
}

void find_answer()
{
    cout << one(B) - one(A-1);
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    dynamic();
    init();
    find_answer();
}
```