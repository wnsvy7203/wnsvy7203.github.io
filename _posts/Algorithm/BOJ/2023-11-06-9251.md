---
title: "[BOJ] 9251. LCS (C++)"
date: 2023-11-06 16:32:00 +09:00
categories: [Algorithm, BOJ]
tags: [Algorithm, BOJ, C++, 다이나믹 프로그래밍, 문자열, Gold 5, CLASS 4]
---
## **문제**
[acmicpc.net/problem/9251](https://www.acmicpc.net/problem/9251)
<br>

LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.

예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.
<br>

## **입력**
첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.
<br>

## **출력**
첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다.
<br>

## **체감 난이도**
🟩🟩⬜⬜⬜
<br>

## **풀이**
복잡하지 않은 dp 문제이다. 주어진 두 문자열의 LCS의 size만 출력하면 되기 때문에, 굳이 char 배열을 사용할 필요 없이, int 배열을 선언해서 길이를 dp 로직을 활용해서 채워나가면 되는 문제이다.

시간제한이 0.1초이기 때문에 대략 천만 번의 연산 안에 문제를 처리해야 한다. 최대 1000글자로 이루어진 2개의 문자열을 완전탐색면서 같은 부분을 찾게 되면 당연히 시간 초과가 날 수밖에 없다.

1. 2중 for문을 활용해서 두 문자열을 순회한다.
2. 일반화해보면, A의 i번 인덱스, B의 j번 인덱스까지의 LCS의 길이가 `dp[i][j]`이다.
3. 만약 A의 i번 인덱스, B의 j번 인덱스가 같은 문자라면 `dp[i+1][j+1] = dp[i][j] + 1`이다.(실제 풀이에서는 1번 인덱스부터 시작하도록 구현해서 `dp[i][j] = dp[i-1][j-1] + 1`이다.)
4. 다른 문자라면 `dp[i][j+1]`, `dp[i+1][j]` 중 최댓값을 그대로 이어나가면 된다.(역시 실제 풀이에서는 `dp[i-1][j]`, `dp[i][j-1]` 중 최댓값을 찾도록 구현되어있다.)

|구분|0|A|C|A|Y|K|P|
|--|--|--|--|--|--|--|--|
|**0**|0|0|0|0|0|0|0|
|**C**|0|0|1|1|1|1|1|
|**A**|0|1|1|2|2|2|2|
|**P**|0|1|1|2|2|2|3|
|**C**|0|1|2|2|2|2|3|
|**A**|0|1|2|3|3|3|3|
|**K**|0|1|2|3|3|4|4|

제대로 dp 로직이 돌아갔다면, 위와 같은 테이블이 만들어진다.
<br>

## **정답 코드**
```c++
// 4ms

#include <iostream>

using namespace std;

string A, B;
int dp[1001][1001];

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> A >> B;
    int a = A.size();
    int b = B.size();

    for (int i = 1; i <= a; i++)
        for (int j = 1; j <= b; j++)
            if (A[i-1] == B[j-1])
                dp[i][j] = dp[i-1][j-1] + 1;
            else
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
    
    cout << dp[a][b];
}
```