---
title: "[BOJ] 17144. 미세먼지 안녕! (C++)"
date: 2023-11-10 23:37:00 +09:00
categories: [Algorithm, BOJ]
tags: [Algorithm, BOJ, C++, 구현, 시뮬레이션, Gold 4, CLASS 4]
---
## **문제**
[acmicpc.net/problem/17144](https://www.acmicpc.net/problem/17144)
<br>

미세먼지를 제거하기 위해 구사과는 공기청정기를 설치하려고 한다. 공기청정기의 성능을 테스트하기 위해 구사과는 집을 크기가 R×C인 격자판으로 나타냈고, 1×1 크기의 칸으로 나눴다. 구사과는 뛰어난 코딩 실력을 이용해 각 칸 (r, c)에 있는 미세먼지의 양을 실시간으로 모니터링하는 시스템을 개발했다. (r, c)는 r행 c열을 의미한다.

![Imgur](https://i.imgur.com/izb7fz8.png)

공기청정기는 항상 1번 열에 설치되어 있고, 크기는 두 행을 차지한다. 공기청정기가 설치되어 있지 않은 칸에는 미세먼지가 있고, (r, c)에 있는 미세먼지의 양은 A<sub>r,c</sub>이다.

1초 동안 아래 적힌 일이 순서대로 일어난다.

1. 미세먼지가 확산된다. 확산은 미세먼지가 있는 모든 칸에서 동시에 일어난다.
    - (r, c)에 있는 미세먼지는 인접한 네 방향으로 확산된다.
    - 인접한 방향에 공기청정기가 있거나, 칸이 없으면 그 방향으로는 확산이 일어나지 않는다.
    - 확산되는 양은 A<sub>r,c</sub>/5이고 소수점은 버린다. 즉, ⌊A<sub>r,c</sub>/5⌋이다.
    - (r, c)에 남은 미세먼지의 양은 A<sub>r,c</sub> - ⌊A<sub>r,c</sub>/5⌋×(확산된 방향의 개수) 이다.
2. 공기청정기가 작동한다.
    - 공기청정기에서는 바람이 나온다.
    - 위쪽 공기청정기의 바람은 반시계방향으로 순환하고, 아래쪽 공기청정기의 바람은 시계방향으로 순환한다.
    - 바람이 불면 미세먼지가 바람의 방향대로 모두 한 칸씩 이동한다.
    - 공기청정기에서 부는 바람은 미세먼지가 없는 바람이고, 공기청정기로 들어간 미세먼지는 모두 정화된다.

다음은 확산의 예시이다.

![Imgur](https://i.imgur.com/04x4omc.png)
왼쪽과 위쪽에 칸이 없기 때문에, 두 방향으로만 확산이 일어났다.

![Imgur](https://i.imgur.com/kR3bkDU.png)
인접한 네 방향으로 모두 확산이 일어난다.

![Imgur](https://i.imgur.com/oiJqob9.png)
공기청정기가 있는 칸으로는 확산이 일어나지 않는다.

공기청정기의 바람은 다음과 같은 방향으로 순환한다.

![Imgur](https://i.imgur.com/nBLlOkO.png)

방의 정보가 주어졌을 때, T초가 지난 후 구사과의 방에 남아있는 미세먼지의 양을 구해보자.
<br>

## **입력**
첫째 줄에 R, C, T (6 ≤ R, C ≤ 50, 1 ≤ T ≤ 1,000) 가 주어진다.

둘째 줄부터 R개의 줄에 A<sub>r,c</sub> (-1 ≤ A<sub>r,c</sub> ≤ 1,000)가 주어진다. 공기청정기가 설치된 곳은 A<sub>r,c</sub>가 -1이고, 나머지 값은 미세먼지의 양이다. -1은 2번 위아래로 붙어져 있고, 가장 윗 행, 아랫 행과 두 칸이상 떨어져 있다.
<br>

## **출력**
첫째 줄에 T초가 지난 후 구사과 방에 남아있는 미세먼지의 양을 출력한다.
<br>

## **체감 난이도**
🟩🟩⬜⬜⬜
<br>

## **풀이**
얼핏 복잡해 보일 수는 있지만, 문제 자체는 매초 순서대로 일어나는 일을 분리해서 동작하도록 구현하기만 하면 되는 문제였다. **구현 문제는 대부분, 문제에서 주어진 것을 잘 읽기만 하는 것으로도 의외로 간단하게 풀리는 경우가 많다.**

먼저, 1초마다 확산과 공기청정기 작동이 반복되기 때문에 해당 로직을 각각 `spread`, `clean`으로 선언했다.
미세먼지의 양을 업데이트하는 데 사용하기 위한 배열과 미세먼지의 양을 나타내는 배열을 따로 선언한 이후, 두 배열을 활용해서 1초마다 배열을 업데이트하는 형식으로 구현했다.
<br>

## **정답 코드**
```c++
// 52ms

#include <iostream>
#include <vector>

using namespace std;

int R, C, T;
int A[50][50];  // 미세먼지
int B[50][50];  // 더하고 빼는 데 써
int dr[4] = {-1, 1, 0, 0};
int dc[4] = {0, 0, -1, 1};

vector<int> con;
int ans;

// 미세먼지 확산 로직
void spread()
{
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
        {
            int cnt = 0;
            int add = A[i][j] / 5;

            // 해당 칸에 미세먼지가 없다면 동작할 필요가 없다.
            if (A[i][j] == 0 || A[i][j] == -1)
                continue;
            
            // 미세먼지가 있다면 4방향을 확인해서 미세먼지 확산
            for (int d = 0; d < 4; d++)
            {
                int nr = i + dr[d];
                int nc = j + dc[d];

                // 범위를 벗어나는 것까지 확인할 필요 없음
                if (nr < 0 || nr >= R || nc < 0 || nc >= C)
                    continue;

                // 공기청정기 방향으로는 미세먼지가 확산되지 않는다고 했다.
                if (A[nr][nc] == -1)
                    continue;
                
                // 확산된 칸 업데이트
                B[nr][nc] += add;

                // 확산될 방향의 개수
                cnt++;
            }
            B[i][j] -= (cnt * add);
        }
    
    // 모든 확산이 정리된 이후, 실제 배열 업데이트        
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
        {
            A[i][j] += B[i][j];
            B[i][j] = 0;
        }
}

// 공기청정기 작동 로직
// 공기청정기를 기준으로 배열의 r, c를 넘어서지 않으면서 정해진 2가지 방향으로 동작함을 고려하여 2가지 로직 동시 진행
void clean()
{
    // 위 (오 -> 위 -> 왼 -> 밑)
    for (int i = con[0]-1; i > 0; i--)
        A[i][0] = A[i-1][0];
    for (int i = 0; i < C-1; i++)
        A[0][i] = A[0][i+1];
    for (int i = 1; i <= con[0]; i++)
        A[i-1][C-1] = A[i][C-1];
    for (int i = C-1; i > 1; i--)
        A[con[0]][i] = A[con[0]][i-1];
    A[con[0]][1] = 0;

    // 아래 (오 -> 밑 -> 왼 -> 위)
    for (int i = con[1]+1; i < R-1; i++)
        A[i][0] = A[i+1][0];
    for (int i = 0; i < C-1; i++)
        A[R-1][i] = A[R-1][i+1];
    for (int i = R-1; i >= con[1]; i--)
        A[i][C-1] = A[i-1][C-1];
    for (int i = C-1; i > 1; i--)
        A[con[1]][i] = A[con[1]][i-1];
    A[con[1]][1] = 0;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> R >> C >> T;
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
        {
            cin >> A[i][j];
            if (A[i][j] == -1)
                con.push_back(i);
        }

    while (T--)
    {
        spread();
        clean();
    }
    
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            if (A[i][j] != -1)
                ans += A[i][j];
    cout << ans;
}
```