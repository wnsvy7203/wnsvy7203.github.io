---
title: "[BOJ] 10164. 격자 상의 경로 (C++)"
date: 2023-11-18 23:46:00 +09:00
categories: [Algorithm, BOJ]
tags: [Algorithm, BOJ, C++, 다이나믹 프로그래밍, Silver 1]
---
## **문제**
[acmicpc.net/problem/11052](https://www.acmicpc.net/problem/11052)
<br>

행의 수가 N이고 열의 수가 M인 격자의 각 칸에 1부터 N×M까지의 번호가 첫 행부터 시작하여 차례로 부여되어 있다. 격자의 어떤 칸은 ○ 표시가 되어 있다. (단, 1번 칸과 N × M번 칸은 ○ 표시가 되어 있지 않다. 또한, ○ 표시가 되어 있는 칸은 최대 한 개이다. 즉, ○ 표시가 된 칸이 없을 수도 있다.) 

행의 수가 3이고 열의 수가 5인 격자에서 각 칸에 번호가 1부터 차례대로 부여된 예가 아래에 있다. 이 격자에서는 8번 칸에 ○ 표시가 되어 있다.

![Imgur](https://i.imgur.com/qw5Kr05.png)
격자의 1번 칸에서 출발한 어떤 로봇이 아래의 두 조건을 만족하면서 N×M번 칸으로 가고자 한다.

- 조건 1: 로봇은 한 번에 오른쪽에 인접한 칸 또는 아래에 인접한 칸으로만 이동할 수 있다. (즉, 대각선 방향으로는 이동할 수 없다.)
- 조건 2: 격자에 ○로 표시된 칸이 있는 경우엔 로봇은 그 칸을 반드시 지나가야 한다. 

위에서 보인 것과 같은 격자가 주어질 때, 로봇이 이동할 수 있는 서로 다른 경로의 두 가지 예가 아래에 있다.

- 1 → 2 → 3 → 8 → 9 → 10 → 15
- 1 → 2 → 3 → 8 → 13 → 14 → 15

격자에 관한 정보가 주어질 때 로봇이 앞에서 설명한 두 조건을 만족하면서 이동할 수 있는 서로 다른 경로가 총 몇 개나 되는지 찾는 프로그램을 작성하라.
<br>

## **입력**
입력의 첫째 줄에는 격자의 행의 수와 열의 수를 나타내는 두 정수 N과 M(1 ≤ N, M ≤ 15), 그리고 ○로 표시된 칸의 번호를 나타내는 정수 K(K=0 또는 1 < K < N×M)가 차례로 주어지며, 각 값은 공백으로 구분된다. K의 값이 0인 경우도 있는데, 이는 ○로 표시된 칸이 없음을 의미한다. N과 M이 동시에 1인 경우는 없다.
<br>

## **출력**
주어진 격자의 정보를 이용하여 설명한 조건을 만족하는 서로 다른 경로의 수를 계산하여 출력해야 한다.
<br>

## **체감 난이도**
🟩⬜⬜⬜⬜
<br>

## **풀이**
다이나믹 프로그래밍 문제이고, 선언한 `dp` 배열의 `i`번째 테이블의 `j`번째 원소는 해당 인덱스까지 도달할 수 있는 최단 경로의 경우의 수를 저장하는 배열이다. 만약 K 값이 0이 아니라면 반드시 K를 거쳐 가야만 한다.

로봇은 한 번에 오른쪽 또는 아래로만 이동할 수 있으므로, **바로 왼쪽에서 넘어오는 경우의 수와 바로 위에서 내려오는 경우의 수를 합하면** `dp[i][j]`를 구할 수 있다.
<br>

## **정답 코드**
```c++
#include <iostream>

using namespace std;

int N, M, K;
int dp[16][16];

int R, C;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> N >> M >> K;
    int num = 1;
    for (int i = 1; i <= N; i++)
        for (int j = 1; j <= M; j++)
        {
            if (num++ == K)
            {
                R = i;
                C = j;
            }
        }
    
    dp[1][1] = 1;
    if (K)
    {
        for (int i = 1; i <= R; i++)
            for (int j = 1; j <= C; j++)
                dp[i][j] = dp[i][j] + dp[i-1][j] + dp[i][j-1];
        
        for (int i = R; i <= N; i++)
            for (int j = C; j <= M; j++)
            {
                if (i == R && j == C)
                    continue;
                dp[i][j] = dp[i][j] + dp[i-1][j] + dp[i][j-1];
            }
    }
    else
        for (int i = 1; i <= N; i++)
            for (int j = 1; j <= M; j++)
                dp[i][j] = dp[i][j] + dp[i-1][j] + dp[i][j-1];
    
    cout << dp[N][M];
}
```