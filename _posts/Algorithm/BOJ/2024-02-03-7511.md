---
title: "[BOJ] 7511. 소셜 네트워킹 어플리케이션 (C++)"
date: 2024-02-03 14:51:00 +09:00
categories: [Algorithm, BOJ]
tags: [Algorithm, BOJ, C++, 자료 구조, 그래프 이론, 그래프 탐색, 분리 집합, Gold 5]
---
## **문제**
[acmicpc.net/problem/7511](https://www.acmicpc.net/problem/7511)

어렸을 때부터 컴퓨터 프로그래밍에 엄청난 소질을 보인 상근이는 항상 소셜 네트워킹 웹사이트를 만들고 싶어 했다. 상근이는 페이스북을 벤치마킹하기 위해 지난 3년간 열심히 사용을 했고, 이제 페이스북의 단점을 보완한 새 소셜 네트워킹 웹 2.0 어플리케이션을 만들려고 한다.

사람들은 소셜 네트워킹 어플리케이션에 가입을 한 다음, 현실에서 아는 사람을 친구로 추가하기 시작한다. 이러한 친구 관계 정보를 이용해 친구 관계 그래프를 그릴 수 있다.

소셜 네트워킹 어플리케이션에서 가장 중요한 기능은 한 사람이 다른 사람의 페이지를 방문했을 때, 친구 관계 그래프에서 두 사람 사이의 경로를 보여주는 기능이다. 경로가 없는 경우에는 보여주지 않는다.

상근이의 서비스는 매우 유명해졌고, 위의 기능은 사람들이 점점 많아질수록 경로를 구하는 시간이 매우 느려지게 되었다. 그 이유는 두 사람 사이의 경로가 없는 경우에 경로를 찾기 위해 너무 오랜시간 그래프를 탐색하기 때문이었다. 따라서, 상근이는 두 사람 사이의 경로가 존재하는지 안 하는지를 미리 구해보려고 한다.

유저의 수와 각 유저의 친구 관계가 입력으로 주어진다. 이때, 주어지는 두 사람이 친구 관계 그래프상에서 경로가 존재하는지 안 하는지를 구하는 프로그램을 작성하시오.
<br>

## **입력**
입력은 여러 개의 테스트 케이스로 이루어져 있다.

각 테스트 케이스의 첫째 줄에는 유저의 수 1 ≤ n ≤ 10<sup>6</sup>이 주어진다. 둘째 줄에는 친구 관계의 수 1 ≤ k ≤ 10<sup>5</sup>가 주어진다. 다음 k개 줄에는 두 정수 0 ≤ a, b < n이 주어진다. 두 수는 친구 관계를 나타내며, 유저 a와 b가 친구라는 소리이다. 다음 줄에는 미리 구할 쌍의 수 1 ≤ m ≤ 10<sup>5</sup>가 주어진다. 다음 m개 줄에는 구해야하는 쌍을 나타내는 u, v가 주어진다.
<br>

## **출력**
각 테스트 케이스마다 "Scenario i:"를 출력한다. i는 테스트 케이스 번호이며, 1부터 시작한다. 그 다음, 각각의 쌍마다 두 사람을 연결하는 경로가 있으면 1, 없으면 0을 출력한다.

각 테스트 케이스 사이에는 빈 줄을 하나 출력한다.
<br>

## **체감 난이도**
🟩⬜⬜⬜⬜
<br>

## **풀이**
출력에만 신경 쓰면 쉽게 맞출 수 있는 문제이다.

문제가 요구하는 것은, **주어진 k만큼 유니온 파인드를 실행**하고, **주어진 m만큼 친구 관계를 파악**하여 친구인지 아닌지 여부를 출력하도록 하는 문제이다.

1. k가 주어진 이후, 다음 k개의 줄에 주어진 a, b를 유니온 파인드로 같은 집합으로 묶어준다(친구 관계를 맺어준다.).
2. m이 주어진 이후, 다음 m개의 줄에 주어진 u, v의 루트 노드를 확인하여 같다면 1, 아니면 0이 정답이다.
3. 출력에 요구하는 것이 많으므로 주의해서 출력한다.
<br>

## **정답 코드**
```c++
// 120ms

#include <iostream>

using namespace std;

int T, n, k, m;
int par[1000000];

int find(int x)
{
    if (par[x] == x)
        return x;
    
    return par[x] = find(par[x]);
}

void union_sets(int x, int y)
{
    x = find(x);
    y = find(y);

    if (x > y)
        swap(x, y);

    par[y] = x;
}

void find_answer()
{
    cin >> m;
    while (m--)
    {
        int u, v;
        cin >> u >> v;
        
        u = find(u);
        v = find(v);

        if (u == v)
            cout << "1\n";
        else
            cout << "0\n";
    }
    cout << '\n';
}

void init()
{
    cin >> T;
    for (int i = 1; i <= T; i++)
    {
        cout << "Scenario " << i << ":\n";

        cin >> n;
        for (int i = 1; i <= n; i++)
            par[i] = i;

        cin >> k;
        while (k--)
        {
            int a, b;
            cin >> a >> b;
            union_sets(a, b);
        }
            
        find_answer();
    }
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    init();
}
```