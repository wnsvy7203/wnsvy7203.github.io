---
title: "[BOJ] 4883. 삼각 그래프 (C++)"
date: 2023-11-18 21:31:00 +09:00
categories: [Algorithm, BOJ]
tags: [Algorithm, BOJ, C++, 다이나믹 프로그래밍, Silver 1]
---
## **문제**
[acmicpc.net/problem/4883](https://www.acmicpc.net/problem/4883)
<br>

이 문제는 삼각 그래프의 가장 위쪽 가운데 정점에서 가장 아래쪽 가운데 정점으로 가는 최단 경로를 찾는 문제이다.

삼각 그래프는 사이클이 없는 그래프로 N ≥ 2 개의 행과 3열로 이루어져 있다. 삼각 그래프는 보통 그래프와 다르게 간선이 아닌 정점에 비용이 있다. 어떤 경로의 비용은 그 경로에서 지나간 정점의 비용의 합이다.

오른쪽 그림은 N = 4인 삼각 그래프이고, 가장 위쪽 가운데 정점에서 가장 아래쪽 가운데 정점으로 경로 중 아래로만 가는 경로의 비용은 7+13+3+6 = 29가 된다. 삼각 그래프의 간선은 항상 아래 그림과 같은 형태로 연결되어 있다.

![Imgur](https://i.imgur.com/HamajOX.png)
<br>

## **입력**
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 그래프의 행의 개수 N이 주어진다. (2 ≤ N ≤ 100,000) 다음 N개 줄에는 그래프의 i번째 행에 있는 정점의 비용이 순서대로 주어진다. 비용은 정수이며, 비용의 제곱은 1,000,000보다 작다.

입력의 마지막 줄에는 0이 하나 주어진다.
<br>

## **출력**
각 테스트 케이스에 대해서, 가장 위쪽 가운데 정점에서 가장 아래쪽 가운데 정점으로 가는 최소 비용을 테스트 케이스 번호와 아래와 같은 형식으로 출력한다.

```
k. n
```

k는 테스트 케이스 번호, n은 최소 비용이다.
<br>

## **체감 난이도**
🟩🟩⬜⬜⬜
<br>

## **풀이**
다이나믹 프로그래밍 문제이고, 선언한 `dp` 배열은 그림에서처럼 지나올 수 있는 경로들의 최솟값들을 더하면서 이동하고 있다. 그림을 잘 확인해서 이동할 수 있는 경로를 판단하여 `dp` 배열을 채워야 한다.

1. 각 `i`번째 테이블의 0번 인덱스, 1번 인덱스, 2번 인덱스를 확인하여 최솟값을 업데이트하는 문제임을 감안해야 한다.
2. 0번 인덱스의 경우, `i-1`번째 테이블의 0번 인덱스, 1번 인덱스 중 최솟값과 입력받은 `board[i][0]`을 더한 값이 저장된다.
3. 1번 인덱스의 경우, `i-1`번째 테이블의 0번 인덱스, 1번 인덱스, 2번 인덱스, 그리고 `i`번째 테이블의 0번 인덱스 중 최솟값과, 입력받은 `board[i][1]`을 더한 값이 저장된다.
4. 마찬가지로 2번 인덱스도 그림을 보고 업데이트하게 되면 최종적으로 dp 배열이 완성되고, 도착점은 `dp[N][1]`이므로, 최종적으로 `dp[N][1]`을 출력하면 된다.
<br>

## **정답 코드**
```c++
// 24ms

#include <iostream>
#include <algorithm>

using namespace std;

int T, N;
int board[100001][3], dp[100001][3];

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    while (1)
    {
        T++;

        cin >> N;
        if (N == 0)
            break;
        
        for (int i = 1; i <= N; i++)
            cin >> board[i][0] >> board[i][1] >> board[i][2];
        
        // 출발점이 board[1][1], 도착점은 board[N][1]이다.
        dp[1][0] = 1000;
        dp[1][1] = board[1][1];
        dp[1][2] = board[1][1] + board[1][2];

        for (int i = 2; i <= N; i++)
        {
            dp[i][0] = board[i][0] + min(dp[i-1][0], dp[i-1][1]);
            dp[i][1] = board[i][1] + min({dp[i-1][0], dp[i-1][1], dp[i-1][2], dp[i][0]});
            dp[i][2] = board[i][2] + min({dp[i-1][1], dp[i-1][2], dp[i][1]});
        }

        cout << T << ". " << dp[N][1] << '\n';
    }
}
```