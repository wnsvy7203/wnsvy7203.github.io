---
title: "[BOJ] 6087. 레이저 통신 (C++)"
date: 2024-02-28 23:44:00 +09:00
categories: [Algorithm, BOJ]
tags: [Algorithm, BOJ, C++, 수학, 누적 합, 비트마스킹, Gold 4]
---
## **문제**
[acmicpc.net/problem/15809](https://www.acmicpc.net/problem/15809)

크기가 1×1인 정사각형으로 나누어진 W×H 크기의 지도가 있다. 지도의 각 칸은 빈 칸이거나 벽이며, 두 칸은 'C'로 표시되어 있는 칸이다.

'C'로 표시되어 있는 두 칸을 레이저로 통신하기 위해서 설치해야 하는 거울 개수의 최솟값을 구하는 프로그램을 작성하시오. 레이저로 통신한다는 것은 두 칸을 레이저로 연결할 수 있음을 의미한다.

레이저는 C에서만 발사할 수 있고, 빈 칸에 거울('/', '\')을 설치해서 방향을 90도 회전시킬 수 있다.

아래 그림은 H = 8, W = 7인 경우이고, 빈 칸은 '.', 벽은 '*'로 나타냈다. 왼쪽은 초기 상태, 오른쪽은 최소 개수의 거울을 사용해서 두 'C'를 연결한 것이다.
<br>

## **입력**
첫 번째 줄에 국가의 수를 나타내는 N과 기록의 수 M이 주어진다. (1 ≤ N, M ≤ 100,000)

두 번째 줄 부터 N개의 줄에 걸쳐 i번째 국가의 병력 A<sub>i</sub> (1 ≤ i ≤ N)가 자연수로 주어진다. (1 ≤ A<sub>i</sub> ≤ 10,000)

다음 M개의 줄에는 기록이 3개의 정수 O, P, Q로 주어진다. O가 1인 경우 P, Q가 서로 동맹을 맺었음을 의미하고, O가 2인 경우 P, Q가 서로 전쟁을 벌였음을 의미한다.

동맹끼리 다시 동맹을 맺거나 전쟁하는 입력은 주어지지 않는다.
<br>

## **출력**
첫째 줄에 남아있는 국가의 수를 출력한다.

다음 줄에 각 국가의 남은 병력의 수를 띄어쓰기를 간격으로 오름차순으로 출력한다.
<br>

## **체감 난이도**
🟩⬜⬜⬜⬜
<br>

## **풀이**
어떤 부분이 맞고 어떤 부분이 틀렸는지 전혀 이해하지 못한 문제이다.

처음부터 맞게 풀었다고 생각했고, 디버그해도 로직 자체는 원하는대로 흘러갔는데 어떤 부분에서 틀린 것이 있었는지 12%에서 넘어가지 못하고 계속 틀렸다. 틀린 코드를 이리저리 만지고 조금씩 수정을 가하다가, 전쟁 부분에서 로직을 조금 수정했더니 맞았다.

아이디어 자체는 복잡하지 않아서, 일반적인 분리 집합 문제로 보고 풀었고, 다만 **동맹과 적의 개념이 추가된 분리 집합** 문제이다. M개의 줄마다 주어진 `O`가 1이면 동맹국가, 2이면 전쟁 시작으로 분류하여 **각각의 함수를 실행되도록 구현**하면 되는 문제였다.
<br>

## **정답 코드**
```c++
// 24ms

#include <iostream>
#include <vector>
#include <algorithm>

#define MAX 100001

using namespace std;

// N: 초기 국가의 수, M: 기록의 수
int N, M;
// A: 국가 소유 병력, par: 일종의 맹주를 나타내는 배열
int A[MAX], par[MAX];

// 부모를 찾는 함수
int find(int x)
{
    if (par[x] == x)
        return x;

    return par[x] = find(par[x]);
}

// merge 로직
void union_sets(int x, int y)
{
    x = find(x);
    y = find(y);

    if (x > y)
        swap(x, y);
    else if (x == y)
        return;
    
    // 작은 쪽으로 합쳐 맹주국가로 만들어줘야 통일성을 유지할 수 있다.
    par[y] = x;
    // 동맹국가는 하나의 국가로 보고 병력도 합친다.
    A[x] += A[y];
    A[y] = 0;
}

void begin_war(int x, int y)
{
    // 동맹국가의 맹주국가끼리 싸운다고 생각하면 편하다.
    x = find(x);
    y = find(y);

    // 계산의 편의를 위해 로직 통일
    if (A[x] > A[y])
        swap(x, y);
    
    else if (A[x] == A[y])
    {
        A[x] = 0; par[x] = 0;
        A[y] = 0; par[y] = 0;
        return;
    }

    // 통일된 로직으로, 큰 것에서 작은 것을 빼고 남은 병력을 구하고, 패배한 국가의 병력은 0으로 만들어준다.
    // 추가로, 패배한 동맹의 맹주국가의 부모를 승리한 동맹의 맹주국가로 변경해준다.
    A[y] -= A[x];
    A[x] = 0;
    par[x] = y;
}

void init()
{
    cin >> N >> M;
    // 초깃값은 자기 자신을 부모로 가진다.
    for (int i = 1; i <= N; i++)
    {
        cin >> A[i];
        par[i] = i;
    }
    
    while (M--)
    {
        int O, P, Q;
        cin >> O >> P >> Q;

        // 1이면 하나의 집합으로 묶고, 2이면 전쟁 시작
        if (O == 1)
            union_sets(P, Q);
        else
            begin_war(P, Q);
    }
}

// 자기 자신이 부모인 국가의 수를 세고, 해당하는 국가의 병력을 ans 배열에 push_back 해준다.
void find_answer()
{
    // 자신이 맹주인 국가의 수
    int cnt = 0;
    // 모든 과정이 끝났을 때, 살아남은 국가의 병력
    vector<int> ans;
    for (int i = 1; i <= N; i++)
    {
        if (par[i] == i)
        {
            ans.push_back(A[i]);
            cnt++;
        }
    }

    // 병력의 오름차순 정렬 필요
    sort(ans.begin(), ans.end());

    cout << cnt << '\n';
    for (int num : ans)
        cout << num << ' ';
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    init();
    find_answer();
}
```