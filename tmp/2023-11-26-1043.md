---
title: "[BOJ - C++] 1043. 거짓말"
date: 2023-11-26 17:50:00 +09:00
categories: [Algorithm, BOJ]
tags: [Algorithm, BOJ, C++, 자료 구조, 그래프 이론, 그래프 탐색, 분리 집합, Gold 4, CLASS 4]
---
## **문제**
[acmicpc.net/problem/1043](https://www.acmicpc.net/problem/1043)
<br>

지민이는 파티에 가서 이야기 하는 것을 좋아한다. 파티에 갈 때마다, 지민이는 지민이가 가장 좋아하는 이야기를 한다. 지민이는 그 이야기를 말할 때, 있는 그대로 진실로 말하거나 엄청나게 과장해서 말한다. 당연히 과장해서 이야기하는 것이 훨씬 더 재미있기 때문에, 되도록이면 과장해서 이야기하려고 한다. 하지만, 지민이는 거짓말쟁이로 알려지기는 싫어한다. 문제는 몇몇 사람들은 그 이야기의 진실을 안다는 것이다. 따라서 이런 사람들이 파티에 왔을 때는, 지민이는 진실을 이야기할 수 밖에 없다. 당연히, 어떤 사람이 어떤 파티에서는 진실을 듣고, 또다른 파티에서는 과장된 이야기를 들었을 때도 지민이는 거짓말쟁이로 알려지게 된다. 지민이는 이런 일을 모두 피해야 한다.

사람의 수 N이 주어진다. 그리고 그 이야기의 진실을 아는 사람이 주어진다. 그리고 각 파티에 오는 사람들의 번호가 주어진다. 지민이는 모든 파티에 참가해야 한다. 이때, 지민이가 거짓말쟁이로 알려지지 않으면서, 과장된 이야기를 할 수 있는 파티 개수의 최댓값을 구하는 프로그램을 작성하시오.
<br>

## **입력**
첫째 줄에 사람의 수 N과 파티의 수 M이 주어진다.

둘째 줄에는 이야기의 진실을 아는 사람의 수와 번호가 주어진다. 진실을 아는 사람의 수가 먼저 주어지고 그 개수만큼 사람들의 번호가 주어진다. 사람들의 번호는 1부터 N까지의 수로 주어진다.

셋째 줄부터 M개의 줄에는 각 파티마다 오는 사람의 수와 번호가 같은 방식으로 주어진다.

N, M은 50 이하의 자연수이고, 진실을 아는 사람의 수는 0 이상 50 이하의 정수, 각 파티마다 오는 사람의 수는 1 이상 50 이하의 정수이다.
<br>

## **출력**
첫째 줄에 문제의 정답을 출력한다.
<br>

## **체감 난이도**
🟩🟩⬜⬜⬜
<br>

## **풀이**
이 문제를 다시 정리하면서, 유니온 파인드를 사용할 줄 알았다면 훨씬 쉬웠을 문제라는 생각이 들었다.

우선은 bfs로 푼 풀이를 소개하도록 하겠다. 
<br>

## **정답 코드**
```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;

int N, M, K;        // N: 사람의 수, M: 파티의 수, K: 진실을 아는 사람의 수
bool known[51];     // 진실을 아는지 모르는지 확인
vector<int> party[51], graph[51];
vector<bool> visited;

queue<int> que;
void bfs(int n)
{
    que.push(n);

    while(!que.empty())
    {
        int f = que.front();
        que.pop();

        for (int num : graph[f])
            if (!known[num])
            {
                known[num] = 1;
                que.push(num);
            }
    }
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> N >> M >> K;
    while (K--)
    {
        int num;
        cin >> num;
        known[num] = true;
    }

    // 파티의 정보를 기억해두어야 하기 때문에 party 배열에 저장해둔다.
    for (int i = 1; i <= M; i++)
    {
        int p;
        cin >> p;
        while (p--)
        {
            int par;
            cin >> par;

            party[i].push_back(par);
        }
    }

    // 조합을 이용해 party의 참가자가 2명 이상이라면
    // 2명씩 짝지어서 graph 배열에 묶어준다.
    for (int i = 1; i <= M; i++)
    {
        visited.clear();
        int len = party[i].size();
        if (len < 2)
            continue;
        
        for (int j = 0; j < len-2; j++)
            visited.push_back(0);
        for (int j = 0; j < 2; j++)
            visited.push_back(1);

        do
        {
            int one = 0;
            int two = 0;
            for (int j = 0; j < len; j++)
            {
                if (visited[j])
                {
                    if (!one)
                        one = party[i][j];
                    else if (!two)
                        two = party[i][j];
                }
            }

            if (one && two)
            {
                graph[one].push_back(two);
                graph[two].push_back(one);
            }

        } while (next_permutation(visited.begin(), visited.end()));
    }
    
    // 일반적인 그래프 탐색, 여기서는 bfs를 활용했다.
    // 알고 있는 사람인지 여부를 knwon 배열에 기록해둔다.
    for (int i = 1; i < 51; i++)
        if (known[i])
            bfs(i);
    
    // 각 파티를 돌면서 아는 사람이 하나라도 있다면
    // flag가 false가 되고, flag가 1로 남아있다면 ans++;
    int ans = 0;
    for (int i = 1; i <= M; i++)
    {
        bool flag = 1;
        for (int p : party[i])
        {
            if (known[p])
                flag = 0;
        }

        if (flag)
            ans++;
    }

    cout << ans;
}
```