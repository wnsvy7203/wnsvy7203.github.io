# 유니티 일반

유니티(Unity)는 게임 개발 및 시뮬레이션을 위한 인기 있는 크로스 플랫폼 게임 엔진입니다. Unity Technologies에서 개발하였으며, 2D 및 3D 게임뿐만 아니라 가상 현실(VR), 증강 현실(AR), 시뮬레이션 및 기타 대화형 경험을 구축하는 데도 사용됩니다. 몇 가지 주요 특징과 개념에 대한 일반적인 설명은 다음과 같습니다:

1. **크로스 플랫폼 지원:**
   - Unity는 다양한 플랫폼에 게임을 배포할 수 있는 크로스 플랫폼 엔진으로, PC, 모바일 기기, 콘솔, 웹, VR/AR 디바이스 등에서 작동할 수 있습니다.
2. **컴포넌트 기반 아키텍처:**
   - Unity는 컴포넌트 기반의 게임 오브젝트 시스템을 사용합니다. 각 게임 오브젝트는 여러 컴포넌트로 구성되어 있고, 이를 통해 기능을 추가하거나 수정할 수 있습니다.
3. **스크립트 언어:**
   - C#과 JavaScript(UnityScript)를 포함한 여러 스크립팅 언어를 지원합니다. 최근 버전에서는 C#을 권장하며, C#을 사용하여 게임 로직을 작성할 수 있습니다.
4. **에디터:**
   - Unity 에디터는 시각적으로 게임 개발을 지원하며, 씬 구성, 자원 관리, 애니메이션, 물리 시뮬레이션, 테스트 등 다양한 작업을 수행할 수 있습니다.
5. **애셋 스토어:**
   - Unity 에셋 스토어에서는 다양한 리소스, 에셋, 플러그인 등을 구매하거나 무료로 다운로드할 수 있어 개발 속도를 높이고 품질을 향상시킬 수 있습니다.
6. **물리 엔진 및 그래픽스 엔진:**
   - Unity는 실시간 물리 엔진 및 강력한 3D 그래픽스 엔진을 제공하여 현실적인 게임 경험을 제공합니다.
7. **커뮤니티 및 문서:**
   - Unity는 강력한 개발자 커뮤니티를 가지고 있으며, 다양한 문서, 튜토리얼, 포럼을 통해 지원을 제공합니다.

Unity는 게임 개발뿐만 아니라 시뮬레이션, 교육, 건축 및 기타 분야에서도 널리 사용되고 있습니다. 많은 게임 및 애플리케이션이 Unity 엔진을 기반으로 개발되어 성공을 거두고 있습니다.



# C# vs C++

C#(C Sharp)과 C++은 모두 프로그래밍 언어이지만, 몇 가지 중요한 차이점이 있습니다. 아래는 주요한 차이점 몇 가지를 설명합니다:

1. **언어의 종류:**
   - **C#:** C#은 Microsoft에서 개발한 객체지향 프로그래밍 언어로, 주로 .NET 프레임워크에서 사용됩니다.
   - **C++:** C++은 범용 목적의 프로그래밍 언어이며, C 언어의 확장으로 시작되었으며, C++에서는 객체지향 프로그래밍 또한 지원합니다.
2. **플랫폼 의존성:**
   - **C#:** 주로 Windows 환경에서 사용되며, .NET 프레임워크의 일부로서 Windows 환경에서 강력한 통합을 제공합니다. Mono 또는 .NET Core를 사용하여 Linux 및 macOS에서도 실행 가능합니다.
   - **C++:** 플랫폼에 중립적이며, 여러 플랫폼에서 컴파일 및 실행될 수 있습니다. 하지만 특정 플랫폼에 종속된 코드를 작성할 수도 있습니다.
3. **가비지 컬렉션(Garbage Collection):**
   - **C#:** 가비지 컬렉션을 통해 메모리 관리가 자동으로 이루어집니다. 개발자는 명시적으로 메모리를 할당하거나 해제할 필요가 없습니다.
   - **C++:** 메모리 관리는 개발자에게 달려 있으며, 명시적으로 메모리를 할당하고 해제해야 합니다.
4. **컴파일 및 실행 방식:**
   - **C#:** 일반적으로 C# 코드는 컴파일러에 의해 중간 언어로 변환되고, 이후 .NET 런타임에서 실행됩니다.
   - **C++:** C++ 코드는 기계어로 직접 컴파일되어 실행됩니다.
5. **성능:**
   - **C#:** 일반적으로 C++에 비해 상대적으로 느린 실행 성능을 가질 수 있습니다.
   - **C++:** 더 직접적인 메모리 제어와 최적화 가능성으로 인해 C++은 일반적으로 높은 성능을 제공할 수 있습니다.
6. **사용 사례:**
   - **C#:** 주로 Windows 기반 응용 프로그램, 웹 개발, 게임 개발 등에 사용됩니다.
   - **C++:** 시스템 프로그래밍, 임베디드 시스템, 게임 엔진, 고성능 응용 프로그램 등 다양한 분야에서 사용됩니다.



# Update, FixedUpdate, LateUpdate

**`Update()` 메소드:**

- 한 프레임당 한 번 호출되며 주로 사용자 입력을 처리하고 게임 상태를 업데이트하는 데 사용됩니다.
- Time.deltaTime을 사용하여 프레임 속도에 독립적인 계산을 수행해야 합니다.
- 예시 사용 사례: 플레이어 입력, 카메라 이동, 애니메이션 등.

**`FixedUpdate()` 메소드:**

- 고정된 시간 간격마다 호출되며 주로 물리 계산 및 업데이트와 같은 시간에 따라 변하는 작업에 사용됩니다.
- 강체 물리학 및 기타 시간 종속적인 작업을 처리하는 데 이상적입니다.
- 프레임 속도에 독립적으로 실행되므로 일관된 물리 업데이트를 제공합니다.

`LateUpdate`는 Unity의 MonoBehaviour 클래스에서 제공하는 또 다른 메소드로, 각 프레임의 끝에 호출됩니다. `LateUpdate`는 일반적으로 `Update` 메소드 후에 호출되며, 다른 스크립트에서 업데이트된 값들을 반영하거나 조정하기 위해 사용됩니다.

주로 `LateUpdate`는 카메라의 움직임과 관련된 작업에 유용합니다. `Update`에서 다른 스크립트에 의해 변경된 위치, 회전 또는 크기와 같은 값을 사용하려면 `LateUpdate`를 활용할 수 있습니다. 이렇게 하면 다른 업데이트 메소드에서의 변경 사항이 적용된 후에 현재 프레임에서의 작업을 수행할 수 있습니다.



# Awake vs. Start vs. OnEnable

1. **호출 시점:**
   - `Awake`: MonoBehaviour가 활성화될 때 한 번만 호출됩니다. 다른 MonoBehaviour의 `Start` 메소드보다 먼저 호출되므로, 다른 스크립트보다 먼저 초기화되어야 하는 것들을 설정하는 데 사용됩니다.
   - `Start`: `Awake` 이후에 호출되며, 모든 MonoBehaviour의 `Awake`가 호출된 후에 실행됩니다.
2. **순서:**
   - `Awake`: Unity에서 게임 오브젝트가 인스턴스화될 때, 스크립트의 `Awake` 메소드는 스크립트가 속한 게임 오브젝트의 모든 스크립트의 `Awake`가 호출된 후에 실행됩니다.
   - `Start`: 모든 `Awake`가 실행된 이후에 호출되므로, 다른 스크립트에서 초기화된 값들을 `Start`에서 사용할 수 있습니다.
3. **활성화 여부:**
   - `Awake`: 게임 오브젝트가 활성화되지 않았더라도 호출됩니다. 따라서 게임 오브젝트가 비활성화된 상태에서도 초기화 작업을 수행할 수 있습니다.
   - `Start`: 게임 오브젝트가 활성화된 상태일 때만 호출되므로, 비활성화된 상태에서는 실행되지 않습니다.

- `OnEnable`: MonoBehaviour가 활성화될 때마다 호출되며, 활성화와 관련된 초기화 작업에 사용됩니다.
- `Start`: MonoBehaviour가 처음으로 활성화될 때 한 번만 호출되며, 일반적으로 초기화 작업에 사용됩니다.



# const vs. readonly

- `const`는 컴파일 타임에 값이 결정되며, `readonly`는 런타임에 결정됩니다.
- `const`는 반드시 선언과 동시에 초기화되어야 하며, 값을 변경할 수 없습니다.
- `readonly`는 초기화를 선언 시 또는 생성자에서 할 수 있으며, 런타임 중에 변경할 수 없습니다.
- `const`는 주로 리터럴 값에 사용되고, `readonly`는 실행 중에 결정되는 값에 사용됩니다.

- `readonly`는 상수에 대한 참조 코드를 생성하는데, `const`는 값을 변경할 경우 사용하는 곳을 전부 다시 컴파일해야 한다는 문제. `readonly`는 상수에 대한 참조 코드를 생성하므로, 일부만 리빌드해도, 사용하는 다른 코드들이 참조를 가지고 있으므로 리빌드 없이 올바르게 사용 가능



# 직렬화

프로그램 종료 이후에도객체에 관한 정보를 남겨두고 싶을 때 직렬화 사용(영속성), 플레이어의 데이터들을 보관하는 데 사용

- public이거나 [SerializeField] 속성이 있어야 한다.
- static, const, readonly가 아니어야 하고
- 직렬화 할 수 있는 필드 타입
- **기본 데이터 타입:**
  - 정수형 (`int`, `short`, `long`, 등)
  - 부동소수점형 (`float`, `double`)
  - 논리형 (`bool`)
  - 문자열 (`string`)
  - 문자 (`char`)
  - 열거형 (`enum`)
- **Unity 기본 데이터 타입:**
  - `Vector2`, `Vector3`, `Vector4`: 2차원, 3차원, 4차원 벡터
  - `Quaternion`: 회전을 나타내는 쿼터니언
  - `Color`: 색상을 나타내는 클래스
  - `Rect`: 2D 사각형을 나타내는 클래스
  - 기타 Unity의 기본 데이터 타입들
- **배열 및 리스트:**
  - 배열 (`int[]`, `string[]`, 등)
  - 리스트 (`List<int>`, `List<string>`, 등)
- **직렬화 가능한 사용자 정의 클래스:**
  - Unity는 사용자 정의 클래스나 구조체를 직렬화할 수 있습니다.
- 이 외에도 Unity에서는 `SerializeField`를 이용하여 private 변수도 직렬화할 수 있습니다. 하지만, Unity에서 직렬화되지 않는 것들도 있습니다. 예를 들면, `Dictionary`와 같은 일부 컬렉션은 직접적으로 Unity에서 인스펙터 창에서 편집할 수 없습니다. 이런 경우에는 사용자 정의 직렬화 로직이나, 직렬화 프로퍼티를 활용해야 합니다.
