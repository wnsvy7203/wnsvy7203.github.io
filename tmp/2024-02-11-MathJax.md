---
title: "[Markdown] MathJax"
date: 2024-02-11 00:31:00 +09:00
categories: [Algorithm, Markdown]
tags: [Algorithm, Markdown, Blog]
---
## **1. 개요**
MathJax는 HTML을 지원하며 웹 및 웹브라우저 상에서 .html 포맷 파일을 통해 `LaTeX`를 지원하며 무료이고, 아파치라이센스로 소스가 공개되어 있다. 모든 브라우저에서 작동하는 수학용 JavaScript 디스플레이 엔진이다.

### **장점**
1. 수행 시간이 빠르다 -> bit 연산이므로 시간복잡도가 O(1)인 경우가 많다. 비트마스크를 이용하는 경우에는 비트의 개수만큼 원소를 다룰 수 있기 때문에 연산 횟수가 늘어날수록 차이가 커진다.
2. 코드가 짧다 -> 집합 연산을 비트 연산자로 작성하기 때문에 훨씬 간결하다.
3. 메모리 사용량이 적다 -> bit가 n개라면 각 bit당 2가지 경우를 표현하기 때문에 총 2<sup>n</sup> 가지 경우의 수를 10bit 이진수 하나로 표현 가능하다. 이처럼 하나의 정수로 매우 많은 경우의 수를 표현할 수 있으므로 메모리 측면에서 효율적이며, 더 많은 데이터를 미리 계산해서 저장해 둘 수 있다.

### **비트마스킹을 활용한 집합 구현**
비트마스크를 이용한 집합 구현은 가장 대표적이다. 하나의 bit가 하나의 원소가 되는 것이다. 
- bit가 켜져 있으면 해당 원소가 집합에 포함되어 있다는 의미이다.

따라서 N비트 정수 변수라면 N개의 원소를 갖는 집합의 부분집합들을 모두 표현할 수 있게 된다. 비트마스킹을 사용하지 않는 경우에는 N개의 boolean 원소를 갖는 배열을 선언해야 했지만, 비트마스킹을 이용하면 **정수 하나로 표현이 가능**하다.

## **2. 비트 연산자**
1. `AND: & (c = a & b)`
    - 두 int 변수 a와 b를 통해서 c를 생성한다고 가정하면, a와 b를 한 bit씩 비교하면서 해당 비트가 둘 다 켜져 있는 경우에만 c의 해당 비트를 켠다.
2. `OR: | (c = a | b)`
    - 해당 비트가 둘 중 하나라도 켜져 있는 경우 c의 해당 비트를 켠다.
3. `XOR: ^ (c = a ^ b)`
    - 해당 비트가 둘 중 하나만 켜져 있는 경우 c의 해당 비트를 켠다.
4. `NOT: ~ (c = ~a)`
    - 정수 하나를 입력받았을 때, 켜져 있는 비트는 끄고, 꺼저 있는 비트는 켠 결과 반환
5. `Shift 연산 (<< >>)`
    - 변수의 비트들을 왼쪽 또는 오른쪽으로 원하는 만큼 움직인다. 움직이고 난 빈 자리는 0으로 채운다. 13(1101)을 오른쪽으로 1bit 움직인다고 하면, 6(0110)이 된다.

## **3. 사용 시 주의점**
1. C에서 비트 연산자들의 우선순위는 비교 연산자보다 낮다. 따라서 원하는 답이 나오지 않을 가능성도 있다.
    - c = (6 & 4 == 4)의 경우 4 == 4 가 우선순위가 높아서 6 & 1의 값이 할당된다.
2. 오버플로우
    - 2의 50승을 구하기 위해 `1 << 50`으로 표현하면, C에서 1이 32bit 상수 취급되므로, 왼쪽으로 50번 shift한 결과로 오버플로우가 발생한다. 따라서 `1LL << 50` 과 같이 표현해야 한다.

## **4. 예시**
```
예시 1. 공집합과 꽉 찬 집합: A = 0; / A = (1 << 10) - 1;
예시 2. 원소 추가: A |= (1 << k);
예시 3. 원소 삭제: A &= ~(1 << k);
예시 4. 원소 포함 여부 확인: if (A & (1 << k))
예시 5. 원소의 토글: A ^= (1 << k); => 특정 비트가 1이면 0, 0이면 1로 바꿈
예시 6. 두 집합 연산: A | B(합집합), A & B(교집합), A & (~B)(A와 B의 차집합), A ^ B(차집합의 합집합)
예시 7. 집합의 크기 구하기
int bitCount(int A)
{
    if (A == 0)
        return 0;
    return A % 2 + bitCount(A/2);
}
내장 명령어:  gcc/g++ => __builtin_popcount(A);
             visual C++ => __popcnt(A);
예시 8. 최소 원소 찾기: A &= (-A);
예시 9. 최소 원소 지우기: A &= (A-1);
예시 10. 모든 부분 집합 순회하기
for (int subset = A; subset; subset = ((subset - 1) & A))
```